/*
 * Copyright (c) 2020 Certinia Inc. All rights reserved.
 */
type LineNumber = number | string | null; // an actual line-number or 'EXTERNAL'
type TruncateKey = 'unexpected' | 'error' | 'skip';
type RGBA = `rgba(${number}, ${number}, ${number}, ${number})`;

export type TimelineKey =
  | 'method'
  | 'systemMethod'
  | 'codeUnit'
  | 'dml'
  | 'soql'
  | 'flow'
  | 'workflow';

enum TruncationColor {
  error = 'rgba(255, 128, 128, 0.2)',
  skip = 'rgba(128, 255, 128, 0.2)',
  unexpected = 'rgba(128, 128, 255, 0.2)',
}
const typePattern = /^[A-Z_]*$/,
  truncateColor: Map<TruncateKey, RGBA> = new Map([
    ['error', TruncationColor.error],
    ['skip', TruncationColor.skip],
    ['unexpected', TruncationColor.unexpected],
  ]),
  newlineRegex = /\r?\n/,
  settingsPattern = /^\d+\.\d+\sAPEX_CODE,\w+;APEX_PROFILING,.+$/m;

let logLines: LogLine[] = [],
  truncated: TruncationEntry[],
  maxSizeTimestamp: number | null = null,
  reasons: Set<string> = new Set<string>(),
  cpuUsed = 0,
  lastTimestamp = null,
  totalDuration = 0, // the maximum display value (in nano-seconds)
  discontinuity = false;

export class LineIterator {
  lines: LogLine[];
  index: number;
  length: number;

  constructor(lines: LogLine[]) {
    this.lines = lines;
    this.index = 0;
    this.length = lines.length;
  }

  peek(): LogLine | null {
    return this.index < this.length ? this.lines[this.index] : null;
  }

  fetch(): LogLine | null {
    return this.index < this.length ? this.lines[this.index++] : null;
  }
}

export class TruncationEntry {
  timestamp: number;
  reason: string;
  color: string;

  constructor(timestamp: number, reason: string, color: string) {
    this.timestamp = timestamp;
    this.reason = reason;
    this.color = color;
  }
}

/**
 * All log lines extend this base class.
 */
export abstract class LogLine {
  // common metadata (available for all lines)
  selfTime = 0; // the net time spent in the node (when not inside children)
  duration = 0; // the time spent in the node
  timestamp = 0; // the timestamp of this log line
  type = ''; // the type of this log line
  logLine = ''; // the raw text of this log line
  text = ''; // the basic descriptive text for this log line

  // optional metadata
  acceptsText = false; // should this log entry pull in following text lines (as the log entry can contain newlines)?
  declarative = false; // is this log entry generated by a declarative process?
  isExit = false; // is a method exit line?
  lineNumber: LineNumber = null; // this log entry has a line number
  namespace: string | null = null; // the namespace of this log line
  value: string | null = null; // a variable value
  hasValidSymbols = false; // can we open source for this node?
  suffix: string | null = null; // extra description context
  prefix: string | null = null; // extra description context
  discontinuity = false; // does this line cause a discontinuity in the call stack?
  rowCount: number | null = null; // the number of rows in a database operation

  constructor(parts: string[] | null) {
    if (parts) {
      this.type = parts[1];
      this.text = this.type;
      this.timestamp = parseTimestamp(parts[0]);
    }
  }

  getBreadcrumbText() {
    return this.type;
  }

  loadContent?(lineIter: LineIterator, stack: Method[]): void;

  onEnd?(end: LogLine, stack: LogLine[]): void;

  onAfter?(next: LogLine): void;
}

/**
 * Log lines extend this class if they have a duration (and hence can be shown on the timeline).
 * There are no real children (as there is no exit line), but children can get reparented here...
 */
export class TimedNode extends LogLine {
  exitStamp: number | null = null; // the timestamp when the node finished
  children: LogLine[] = []; // our child nodes

  timelineKey: TimelineKey; // the formatting key for rendering this entry in the timeline
  cpuType: string; // the catagory key to collect our cpu usage
  totalDmlCount = 0; // the number of DML_BEGIN decendants in a node
  totalSoqlCount = 0; // the number of SOQL_EXECUTE_BEGIN decendants in a node
  totalThrownCount = 0; // the number of EXCEPTION_THROWN decendants in a node

  constructor(parts: string[] | null, timelineKey: TimelineKey, cpuType: string) {
    super(parts);
    this.timelineKey = timelineKey;
    this.cpuType = cpuType;
  }

  getBreadcrumbText() {
    let desc = this.text;

    const brace = desc.indexOf('(');
    if (brace >= 0) {
      desc = desc.substring(0, brace);
    }

    const dot = desc.lastIndexOf('.');
    if (dot >= 0) {
      desc = desc.substring(dot + 1);
    }

    return desc;
  }

  addChild(line: LogLine) {
    this.children.push(line);
  }

  recalculateDurations() {
    if (this.exitStamp) {
      this.duration = this.exitStamp - this.timestamp;

      let childDuration = 0;
      this.children.forEach((child) => {
        childDuration += child.duration;
      });
      this.selfTime = this.duration - childDuration;
    }
  }
}

/**
 * Log lines extend this class if they have a start-line and an end-line (and hence can have children in-between).
 * - The start-line should extend "Method" and collect any children.
 * - The end-line should extend "Detail" and terminate the method (also providing the "exitStamp").
 * The method will be rendered as "expandable" in the tree-view, if it has children.
 */
export class Method extends TimedNode {
  exitTypes: string[]; // the line types which would legitimately end this method
  classes: string; // css classes to apply to this method
  isTruncated = false; // was the method truncated when the log ended?

  constructor(
    parts: string[] | null,
    exitTypes: string[],
    classes: string | null,
    timelineKey: TimelineKey,
    cpuType: string
  ) {
    super(parts, timelineKey, cpuType);
    this.exitTypes = exitTypes;
    this.classes = classes ? 'node ' + classes : 'node';
  }

  isMatchingEnd(endLine: LogLine) {
    return (
      this.exitTypes.includes(endLine.type) &&
      (!endLine.lineNumber || !this.lineNumber || endLine.lineNumber === this.lineNumber)
    );
  }

  endMethod(endLine: LogLine, lineIter: LineIterator, stack: Method[]) {
    this.exitStamp = endLine.timestamp;

    // is this a 'good' end line?
    if (this.isMatchingEnd(endLine)) {
      discontinuity = false; // end stack unwinding
      lineIter.fetch(); // consume the line
      return true; // success
    } else if (discontinuity) {
      return true; // exception - unwind
    } else {
      if (stack.some((m) => m.isMatchingEnd(endLine))) {
        return true; // we match a method further down the stack - unwind
      }
      // we found an exit event on its own e.g a `METHOD_EXIT` without a `METHOD_ENTRY`
      truncateLog(endLine.timestamp, 'Unexpected-Exit', 'unexpected');
      return false; // we have no matching method - ignore
    }
  }

  loadContent(lineIter: LineIterator, stack: Method[]) {
    lastTimestamp = this.timestamp;

    if (this.exitTypes.length > 0) {
      let line;

      stack.push(this);
      while ((line = lineIter.peek())) {
        if (line.discontinuity) {
          // discontinuities are stack unwinding (caused by Exceptions)
          discontinuity = true; // start unwinding stack
        }

        if (line.isExit && this.endMethod(line, lineIter, stack)) {
          if (this.onEnd) {
            // the method wants to see the exit line
            this.onEnd(line, stack);
          }
          break;
        }

        if (maxSizeTimestamp && discontinuity && line.timestamp > maxSizeTimestamp) {
          this.isTruncated = true;
          break;
        }

        lineIter.fetch(); // it's a child - consume the line
        lastTimestamp = line.timestamp;
        line.loadContent?.(lineIter, stack);
        this.addChild(line);
      }

      if (!line || this.isTruncated) {
        // truncated method - terminate at the end of the log
        this.exitStamp = lastTimestamp;

        // we found an entry event on its own e.g a `METHOD_ENTRY` without a `METHOD_EXIT` and got to the end of the log
        truncateLog(lastTimestamp, 'Unexpected-End', 'unexpected');
        if (this.isTruncated) {
          updateTruncated(lastTimestamp, 'Max-Size-reached', 'skip');
        }
        this.isTruncated = true;
      }

      stack.pop();
      this.recalculateDurations();
    }
  }
}

/**
 * This class represents the single root node for the node tree.
 * It is a "pseudo" node and not present in the log.
 * Since it has children it extends "Method".
 */
export class RootNode extends Method {
  text = 'Log Root';
  type = 'ROOT';
  timestamp = 0;
  exitStamp = 0;
  /**
   * The endtime with nodes of 0 duration excluded
   */
  executionEndTime = 0;

  constructor() {
    super(null, [], 'root', 'codeUnit', '');
  }

  setTimes() {
    this.timestamp =
      this.children.find((child) => {
        return child.timestamp;
      })?.timestamp || 0;
    // We do not just want to use the very last exitStamp because it could be CUMULATIVE_USAGE which is not really part of the code execution time but does have a later time.
    let endTime;
    const reverseLen = this.children.length - 1;
    for (let i = reverseLen; i >= 0; i--) {
      const child = this.children[i];
      // If there is no duration on a node then it is not going to be shown on the timeline anyway
      if (child instanceof TimedNode && child.exitStamp) {
        endTime ??= child.exitStamp;
        if (child.duration) {
          this.executionEndTime = child.exitStamp;
          break;
        }
      }
      endTime ??= child.timestamp;
    }
    this.exitStamp = endTime || 0;
  }
}

export function truncateLog(timestamp: number, reason: string, colorKey: TruncateKey) {
  if (!reasons.has(reason)) {
    reasons.add(reason);
    // default to error is probably the safest if we have no matching color for the type
    const color = truncateColor.get(colorKey) || TruncationColor.error;
    truncated.push(new TruncationEntry(timestamp, reason, color));

    if (reason === 'Max-Size-reached') {
      maxSizeTimestamp = timestamp;
    }

    truncated.sort((a, b) => a.timestamp - b.timestamp);
  }
}

function updateTruncated(timestamp: number, reason: string, colorKey: TruncateKey) {
  const elem = truncated.findIndex((item) => {
    return item.reason === reason;
  });
  if (elem > -1) {
    truncated.splice(elem, 1);
  }
  reasons.delete(reason);

  truncateLog(timestamp, reason, colorKey);
}

export function parseObjectNamespace(text: string): string {
  const sep = text.indexOf('__');
  if (sep < 0) {
    return 'unmanaged';
  }
  return text.substring(0, sep);
}

export function parseVfNamespace(text: string): string {
  const sep = text.indexOf('__');
  if (sep < 0) {
    return 'unmanaged';
  }
  const firstSlash = text.indexOf('/');
  if (firstSlash < 0) {
    return 'unmanaged';
  }
  const secondSlash = text.indexOf('/', firstSlash + 1);
  if (secondSlash < 0) {
    return 'unmanaged';
  }
  return text.substring(secondSlash + 1, sep);
}

export function parseTimestamp(text: string): number {
  const timestamp = text.slice(text.indexOf('(') + 1, -1);
  if (timestamp) {
    return Number(timestamp);
  }
  throw new Error(`Unable to parse timestamp: '${text}'`);
}

export function parseLineNumber(text: string): string | number {
  const lineNumberStr = text.slice(1, -1);
  if (lineNumberStr) {
    const lineNumber = Number(lineNumberStr);
    return !Number.isNaN(lineNumber) ? lineNumber : lineNumberStr;
  }
  throw new Error(`Unable to parse line number: '${text}'`);
}

export function parseRows(text: string): number {
  const rowCount = text.slice(text.indexOf('Rows:') + 5);
  if (rowCount) {
    return Number(rowCount);
  }
  throw new Error(`Unable to parse row count: '${text}'`);
}

/* Log line entry Parsers */

class BulkHeapAllocateLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = parts[2];
  }
}

class CalloutRequestLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = `${parts[3]} : ${parts[2]}`;
  }
}

class CalloutResponseLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = `${parts[3]} : ${parts[2]}`;
  }
}
class NamedCredentialRequestLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = `${parts[3]} : ${parts[4]} : ${parts[5]} : ${parts[6]}`;
  }
}

class NamedCredentialResponseLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = `${parts[2]}`;
  }
}

class NamedCredentialResponseDetailLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = `${parts[3]} : ${parts[4]} ${parts[5]} : ${parts[6]} ${parts[7]}`;
  }
}

class ConstructorEntryLine extends Method {
  hasValidSymbols = true;
  suffix = ' (constructor)';

  constructor(parts: string[]) {
    super(parts, ['CONSTRUCTOR_EXIT'], null, 'method', 'method');
    this.lineNumber = parseLineNumber(parts[2]);
    const args = parts[4];
    this.text = parts[5] + args.substring(args.lastIndexOf('('));
  }
}

class ConstructorExitLine extends LogLine {
  isExit = true;

  constructor(parts: string[]) {
    super(parts);
    this.lineNumber = parseLineNumber(parts[2]);
  }
}

class EmailQueueLine extends LogLine {
  acceptsText = true;
  constructor(parts: string[]) {
    super(parts);
    this.lineNumber = parseLineNumber(parts[2]);
  }
}

export class MethodEntryLine extends Method {
  hasValidSymbols = true;

  constructor(parts: string[]) {
    super(parts, ['METHOD_EXIT'], null, 'method', 'method');
    this.lineNumber = parseLineNumber(parts[2]);
    this.text = parts[4] || this.type;
    if (this.text === 'System.Type.forName(String, String)') {
      this.cpuType = 'loading'; // assume we are not charged for class loading (or at least not lengthy remote-loading / compiling)
      // no namespace or it will get charged...
    }
  }
}
class MethodExitLine extends LogLine {
  isExit = true;

  constructor(parts: string[]) {
    super(parts);
    this.lineNumber = parseLineNumber(parts[2]);
  }
}

class SystemConstructorEntryLine extends Method {
  suffix = '(system constructor)';

  constructor(parts: string[]) {
    super(parts, ['SYSTEM_CONSTRUCTOR_EXIT'], 'system', 'systemMethod', 'method');
    this.lineNumber = parseLineNumber(parts[2]);
    this.text = parts[3];
  }
}

class SystemConstructorExitLine extends LogLine {
  isExit = true;

  constructor(parts: string[]) {
    super(parts);
    this.lineNumber = parseLineNumber(parts[2]);
  }
}
class SystemMethodEntryLine extends Method {
  constructor(parts: string[]) {
    super(parts, ['SYSTEM_METHOD_EXIT'], 'system', 'systemMethod', 'method');
    this.lineNumber = parseLineNumber(parts[2]);
    this.text = parts[3];
  }
}

class SystemMethodExitLine extends LogLine {
  isExit = true;

  constructor(parts: string[]) {
    super(parts);
    this.lineNumber = parseLineNumber(parts[2]);
  }
}

const cpuMap: Map<string, string> = new Map([
  ['EventService', 'method'],
  ['Validation', 'custom'],
  ['Workflow', 'custom'],
  ['Flow', 'custom'],
]);

export class CodeUnitStartedLine extends Method {
  suffix = ' (entrypoint)';
  codeUnitType = '';

  constructor(parts: string[]) {
    super(parts, ['CODE_UNIT_FINISHED'], null, 'codeUnit', CodeUnitStartedLine.getCpuType(parts));

    const subParts = parts[3].split(':'),
      name = parts[4] || parts[3];

    this.codeUnitType = subParts[0] || parts[4].split('/')[0];
    switch (this.codeUnitType) {
      case 'EventService':
        this.cpuType = 'method';
        this.namespace = parseObjectNamespace(subParts[1]);

        this.text = parts[3];
        break;
      case 'Validation':
        this.cpuType = 'custom';
        this.declarative = true;

        this.text = name || this.codeUnitType + ':' + subParts[1];
        break;
      case 'Workflow':
        this.cpuType = 'custom';
        this.declarative = true;
        this.text = name || this.codeUnitType;
        break;
      case 'Flow':
        this.cpuType = 'custom';
        this.declarative = true;
        this.text = name || this.codeUnitType;
        break;
      default:
        this.cpuType = 'method';
        if (name?.startsWith('VF:')) {
          this.namespace = parseVfNamespace(name);
        }
        this.text = name || parts[3];
        break;
    }
  }

  getBreadcrumbText(): string {
    return 'Code Unit';
  }

  static getCpuType(parts: string[]) {
    const subParts = parts[3].split(':'),
      codeUnitType = subParts[0],
      cpuType = cpuMap.get(codeUnitType);

    return cpuType ?? 'method';
  }
}
export class CodeUnitFinishedLine extends LogLine {
  isExit = true;

  constructor(parts: string[]) {
    super(parts);
    this.text = parts[2];
  }
}

class VFApexCallStartLine extends Method {
  suffix = ' (VF APEX)';
  invalidClasses = [
    'pagemessagescomponentcontroller',
    'pagemessagecomponentcontroller',
    'severitymessages',
  ];

  constructor(parts: string[]) {
    super(parts, ['VF_APEX_CALL_END'], null, 'method', 'method');
    this.lineNumber = parseLineNumber(parts[2]);

    const classText = parts[5] || parts[3];
    let methodtext = parts[4] || '';
    if (
      !methodtext &&
      (!classText.includes(' ') ||
        this.invalidClasses.some((invalidCls: string) =>
          classText.toLowerCase().includes(invalidCls)
        ))
    ) {
      // we have a system entry and they do not have exits
      // e.g |VF_APEX_CALL_START|[EXTERNAL]|/apexpage/pagemessagescomponentcontroller.apex <init>
      // and they really mess with the logs so skip handling them.
      this.exitTypes = [];
    } else if (methodtext) {
      this.hasValidSymbols = true;
      // method call
      const methodIndex = methodtext.indexOf('(');
      const constructorIndex = methodtext.indexOf('<init>');
      if (methodIndex > -1) {
        // Method
        methodtext = '.' + methodtext.substring(methodIndex).slice(1, -1) + '()';
      } else if (constructorIndex > -1) {
        // Constructor
        methodtext = methodtext.substring(constructorIndex + 6) + '()';
      } else {
        // Property
        methodtext = '.' + methodtext;
      }
    } else {
      this.hasValidSymbols = true;
    }
    this.text = classText + methodtext;
  }

  getBreadcrumbText(): string {
    return 'VF Apex';
  }
}

class VFApexCallEndLine extends LogLine {
  isExit = true;

  constructor(parts: string[]) {
    super(parts);
    this.text = parts[2];
  }
}

class VFDeserializeViewstateBeginLine extends Method {
  constructor(parts: string[]) {
    super(parts, ['VF_DESERIALIZE_VIEWSTATE_END'], null, 'systemMethod', 'method');
  }

  getBreadcrumbText(): string {
    return 'Viewstate';
  }
}

class VFDeserializeViewstateEndLine extends LogLine {
  isExit = true;

  constructor(parts: string[]) {
    super(parts);
  }
}

class VFFormulaStartLine extends Method {
  suffix = ' (VF FORMULA)';

  constructor(parts: string[]) {
    super(parts, ['VF_EVALUATE_FORMULA_END'], 'formula', 'systemMethod', 'custom');
    this.text = parts[3];
  }

  getBreadcrumbText(): string {
    return 'VF Formula';
  }
}

class VFFormulaEndLine extends LogLine {
  isExit = true;

  constructor(parts: string[]) {
    super(parts);
    this.text = parts[2];
  }
}

class VFSeralizeViewStateStartLine extends Method {
  namespace = 'system';

  constructor(parts: string[]) {
    super(parts, ['VF_SERIALIZE_VIEWSTATE_END'], null, 'systemMethod', 'method');
  }

  getBreadcrumbText(): string {
    return 'VF Serialize';
  }
}

class VFSeralizeViewStateEndLine extends LogLine {
  isExit = true;

  constructor(parts: string[]) {
    super(parts);
  }
}

class VFPageMessageLine extends LogLine {
  acceptsText = true;
  constructor(parts: string[]) {
    super(parts);
    this.text = parts[2];
  }
}

class DMLBeginLine extends Method {
  constructor(parts: string[]) {
    super(parts, ['DML_END'], null, 'dml', 'free');
    this.lineNumber = parseLineNumber(parts[2]);
    this.text = 'DML ' + parts[3] + ' ' + parts[4];
    this.rowCount = parseRows(parts[5]);
  }

  getBreadcrumbText(): string {
    return 'DML';
  }
}

class DMLEndLine extends LogLine {
  isExit = true;

  constructor(parts: string[]) {
    super(parts);
    this.lineNumber = parseLineNumber(parts[2]);
  }
}

class IdeasQueryExecuteLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.lineNumber = parseLineNumber(parts[2]);
  }
}

class SOQLExecuteBeginLine extends Method {
  aggregations = 0;

  constructor(parts: string[]) {
    super(parts, ['SOQL_EXECUTE_END'], null, 'soql', 'free');
    this.lineNumber = parseLineNumber(parts[2]);

    const [, , , aggregations, soqlString] = parts;

    const aggregationIndex = aggregations.indexOf('Aggregations:');
    this.aggregations = Number(aggregations.slice(aggregationIndex + 13));
    this.text = soqlString;
  }

  getBreadcrumbText(): string {
    return 'SOQL';
  }

  onEnd(end: SOQLExecuteEndLine, _stack: LogLine[]): void {
    this.rowCount = end.rowCount;
  }
}

class SOQLExecuteEndLine extends LogLine {
  isExit = true;

  constructor(parts: string[]) {
    super(parts);
    this.lineNumber = parseLineNumber(parts[2]);
    this.rowCount = parseRows(parts[3]);
  }
}

class SOQLExecuteExplainLine extends LogLine {
  cardinality: number | null = null; // The estimated number of records that the leading operation type would return
  fields: string[] | null = null; //The indexed field(s) used by the Query Optimizer. If the leading operation type is Index, the fields value is Index. Otherwise, the fields value is null.
  leadingOperationType: string | null = null; // The primary operation type that Salesforce will use to optimize the query.
  relativeCost: number | null = null; // The cost of the query compared to the Force.com Query Optimizer’s selectivity threshold. Values above 1 mean that the query won’t be selective.
  sObjectCardinality: number | null = null; // The approximate record count for the queried object.
  sObjectType: string | null = null; //T he name of the queried SObject

  constructor(parts: string[]) {
    super(parts);
    this.lineNumber = parseLineNumber(parts[2]);
    this.text = `${parts[3]}, line:${this.lineNumber}`;

    const queryplanParts = parts[3].split('],');
    if (queryplanParts.length > 1) {
      const planExplain = queryplanParts[0];
      const [cardinalityText, sobjCardinalityText, costText] = queryplanParts[1].split(',');

      const onIndex = planExplain.indexOf(' on');
      this.leadingOperationType = planExplain.slice(0, onIndex);

      const colonIndex = planExplain.indexOf(' :');
      this.sObjectType = planExplain.slice(onIndex + 4, colonIndex);

      // remove whitespace if there is any. we could have [ field1__c, field2__c ]
      // I am not 100% sure of format when we have multiple fields so this is safer
      const fieldsAsString = planExplain.slice(planExplain.indexOf('[') + 1).replace(/\s+/g, '');
      this.fields = fieldsAsString === '' ? [] : fieldsAsString.split(',');

      this.cardinality = Number(
        cardinalityText.slice(cardinalityText.indexOf('cardinality: ') + 13)
      );
      this.sObjectCardinality = Number(
        sobjCardinalityText.slice(sobjCardinalityText.indexOf('sobjectCardinality: ') + 20)
      );
      this.relativeCost = Number(costText.slice(costText.indexOf('relativeCost ') + 13));
    }
  }
}

class SOSLExecuteBeginLine extends Method {
  constructor(parts: string[]) {
    super(parts, ['SOSL_EXECUTE_END'], null, 'soql', 'free');
    this.lineNumber = parseLineNumber(parts[2]);
    this.text = `SOSL: ${parts[3]}`;
  }

  getBreadcrumbText(): string {
    return 'SOSL';
  }

  onEnd(end: SOSLExecuteEndLine, _stack: Detail[]): void {
    this.rowCount = end.rowCount;
  }
}

class SOSLExecuteEndLine extends LogLine {
  isExit = true;

  constructor(parts: string[]) {
    super(parts);
    this.lineNumber = parseLineNumber(parts[2]);
    this.rowCount = parseRows(parts[3]);
  }
}

class HeapAllocateLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.lineNumber = parseLineNumber(parts[2]);
    this.text = parts[3];
  }
}

class HeapDeallocateLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.lineNumber = parseLineNumber(parts[2]);
  }
}

class StatementExecuteLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.lineNumber = parseLineNumber(parts[2]);
  }
}

class VariableScopeBeginLine extends LogLine {
  prefix = 'ASSIGN ';
  classes = 'node detail';

  constructor(parts: string[]) {
    super(parts);
    this.lineNumber = parseLineNumber(parts[2]);
    this.text = parts[3];
    this.value = parts[4];
  }

  onEnd(end: LogLine, _stack: LogLine[]): void {
    if (end.value) {
      this.value = end.value;
    }
    console.debug('NEVER HIT?');
  }
}

class VariableScopeEndLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
  }
}
class VariableAssignmentLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.lineNumber = parseLineNumber(parts[2]);
    this.text = parts[3];
    this.value = parts[4];
  }
}
class UserInfoLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.lineNumber = parseLineNumber(parts[2]);
    this.text = this.type + ':' + parts[3] + ' ' + parts[4];
  }
}

class UserDebugLine extends LogLine {
  acceptsText = true;

  constructor(parts: string[]) {
    super(parts);
    this.lineNumber = parseLineNumber(parts[2]);
    this.text = parts[3];
    this.value = parts[4];
  }
}

class CumulativeLimitUsageLine extends Method {
  constructor(parts: string[]) {
    super(parts, ['CUMULATIVE_LIMIT_USAGE_END'], null, 'systemMethod', 'system');
  }

  getBreadcrumbText(): string {
    return 'Usage';
  }
}

class CumulativeLimitUsageEndLine extends LogLine {
  isExit = true;

  constructor(parts: string[]) {
    super(parts);
  }
}

class CumulativeProfilingLine extends LogLine {
  acceptsText = true;

  constructor(parts: string[]) {
    super(parts);
    this.text = parts[2] + ' ' + (parts[3] ?? '');
  }
}

class CumulativeProfilingBeginLine extends Method {
  constructor(parts: string[]) {
    super(parts, ['CUMULATIVE_PROFILING_END'], null, 'systemMethod', 'custom');
  }

  getBreadcrumbText(): string {
    return 'Profiling';
  }
}

class CumulativeProfilingEndLine extends LogLine {
  isExit = true;

  constructor(parts: string[]) {
    super(parts);
  }
}

class LimitUsageLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.lineNumber = parseLineNumber(parts[2]);
    this.text = parts[3] + ' ' + parts[4] + ' out of ' + parts[5];
  }
}

class LimitUsageForNSLine extends LogLine {
  acceptsText = true;

  constructor(parts: string[]) {
    super(parts);
    this.text = parts[2];
  }

  onAfter(_next: LogLine): void {
    const matched = this.text.match(/Maximum CPU time: (\d+)/),
      cpuText = matched ? matched[1] : '0',
      cpuTime = parseInt(cpuText, 10) * 1000000; // convert from milli-seconds to nano-seconds

    if (!cpuUsed || cpuTime > cpuUsed) {
      cpuUsed = cpuTime;
    }
  }
}

class PushTraceFlagsLine extends LogLine {
  namespace = 'system';

  constructor(parts: string[]) {
    super(parts);
    this.lineNumber = parseLineNumber(parts[2]);
    this.text = parts[4] + ', line:' + this.lineNumber + ' - ' + parts[5];
  }
}

class PopTraceFlagsLine extends LogLine {
  namespace = 'system';

  constructor(parts: string[]) {
    super(parts);
    this.lineNumber = parseLineNumber(parts[2]);
    this.text = parts[4] + ', line:' + this.lineNumber + ' - ' + parts[5];
  }
}

class QueryMoreBeginLine extends Method {
  constructor(parts: string[]) {
    super(parts, ['QUERY_MORE_END'], null, 'soql', 'custom');
    this.lineNumber = parseLineNumber(parts[2]);
    this.text = `line: ${this.lineNumber}`;
  }

  getBreadcrumbText(): string {
    return 'Query More';
  }
}

class QueryMoreEndLine extends LogLine {
  isExit = true;

  constructor(parts: string[]) {
    super(parts);
    this.lineNumber = parseLineNumber(parts[2]);
    this.text = `line: ${this.lineNumber}`;
  }
}
class QueryMoreIterationsLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.lineNumber = parseLineNumber(parts[2]);
    this.text = `line: ${this.lineNumber}, iterations:${parts[3]}`;
  }
}

class SavepointRollbackLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.lineNumber = parseLineNumber(parts[2]);
    this.text = `${parts[3]}, line: ${this.lineNumber}`;
  }
}

class SavePointSetLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.lineNumber = parseLineNumber(parts[2]);
    this.text = `${parts[3]}, line: ${this.lineNumber}`;
  }
}

class TotalEmailRecipientsQueuedLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = parts[2];
  }
}

class StackFrameVariableListLine extends LogLine {
  acceptsText = true;

  constructor(parts: string[]) {
    super(parts);
  }
}

class StaticVariableListLine extends LogLine {
  acceptsText = true;

  constructor(parts: string[]) {
    super(parts);
  }
}

// This looks like a method, but the exit line is often missing...
class SystemModeEnterLine extends LogLine {
  // namespace = "system";

  constructor(parts: string[]) {
    super(parts);
    this.text = parts[2];
  }
}

class SystemModeExitLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = parts[2];
  }
}

export class ExecutionStartedLine extends Method {
  constructor(parts: string[]) {
    super(parts, ['EXECUTION_FINISHED'], null, 'method', 'method');
  }

  getBreadcrumbText(): string {
    return 'Started';
  }
}

export class ExecutionFinishedLine extends LogLine {
  isExit = true;

  constructor(parts: string[]) {
    super(parts);
  }
}

class EnteringManagedPackageLine extends Method {
  constructor(parts: string[]) {
    super(parts, [], null, 'method', 'pkg');
    const rawNs = parts[2],
      lastDot = rawNs.lastIndexOf('.');

    this.namespace = lastDot < 0 ? rawNs : rawNs.substring(lastDot + 1);
    this.text = this.type + ' : ' + this.namespace;
  }

  onAfter(end: LogLine): void {
    this.exitStamp = end.timestamp;
  }
}

class EventSericePubBeginLine extends Method {
  constructor(parts: string[]) {
    super(parts, ['EVENT_SERVICE_PUB_END'], null, 'flow', 'custom');
    this.text = parts[2];
  }

  getBreadcrumbText(): string {
    return 'Pub Begin';
  }
}

class EventSericePubEndLine extends LogLine {
  isExit = true;

  constructor(parts: string[]) {
    super(parts);
    this.text = parts[2];
  }
}

class EventSericePubDetailLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = parts[2] + ' ' + parts[3] + ' ' + parts[4];
  }
}

class EventSericeSubBeginLine extends Method {
  constructor(parts: string[]) {
    super(parts, ['EVENT_SERVICE_SUB_END'], null, 'flow', 'custom');
    this.text = `${parts[2]} ${parts[3]}`;
  }

  getBreadcrumbText(): string {
    return 'Sub Begin';
  }
}

class EventSericeSubEndLine extends LogLine {
  isExit = true;

  constructor(parts: string[]) {
    super(parts);
    this.text = `${parts[2]} ${parts[3]}`;
  }
}

class EventSericeSubDetailLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = `${parts[2]} ${parts[3]} ${parts[4]} ${parts[6]} ${parts[6]}`;
  }
}

export class FlowStartInterviewsBeginLine extends Method {
  declarative = true;
  text = 'FLOW_START_INTERVIEWS : ';

  constructor(parts: string[]) {
    super(parts, ['FLOW_START_INTERVIEWS_END'], null, 'flow', 'custom');
  }

  onEnd(end: FlowStartInterviewsEndLine, stack: LogLine[]) {
    const flowType = this.getFlowType(stack);
    this.suffix = ` (${flowType})`;
    this.text += this.getFlowName();
  }

  getFlowType(stack: LogLine[]) {
    let flowType;
    // ignore the last one on stack is it will be this FlowStartInterviewsBeginLine
    const len = stack.length - 2;
    for (let i = len; i >= 0; i--) {
      const elem = stack[i];
      // type = "CODE_UNIT_STARTED" a flow or Processbuilder was started directly
      // type = "FLOW_START_INTERVIEWS_BEGIN" a flow was started from a process builder
      if (elem instanceof CodeUnitStartedLine) {
        flowType = elem.codeUnitType === 'Flow' ? 'Flow' : 'Process Builder';
        break;
      } else if (elem.type === 'FLOW_START_INTERVIEWS_BEGIN') {
        flowType = 'Flow';
        break;
      }
    }
    return flowType || '';
  }

  getBreadcrumbText(): string {
    return 'Flow';
  }

  getFlowName() {
    if (this.children.length) {
      return this.children[0].text;
    }
    return '';
  }
}

class FlowStartInterviewsEndLine extends LogLine {
  isExit = true;

  constructor(parts: string[]) {
    super(parts);
  }
}

class FlowStartInterviewsErrorLine extends LogLine {
  acceptsText = true;
  constructor(parts: string[]) {
    super(parts);
    this.text = `${parts[2]} - ${parts[4]}`;
  }
}

class FlowStartInterviewBeginLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = parts[3];
  }
}

class FlowStartInterviewEndLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
  }
}

class FlowStartInterviewLimitUsageLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = parts[2];
  }
}

class FlowStartScheduledRecordsLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = `${parts[2]} : ${parts[3]}`;
  }
}
class FlowCreateInterviewBeginLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
  }
}

class FlowCreateInterviewEndLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
  }
}

class FlowCreateInterviewErrorLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = `${parts[2]} : ${parts[3]} : ${parts[4]} : ${parts[5]}`;
  }
}

class FlowElementBeginLine extends Method {
  declarative = true;

  constructor(parts: string[]) {
    super(parts, ['FLOW_ELEMENT_END'], null, 'flow', 'custom');
    this.text = this.type + ' : ' + parts[3] + ' ' + parts[4];
  }

  getBreadcrumbText(): string {
    return 'Flow';
  }
}

class FlowElementEndLine extends LogLine {
  isExit = true;

  constructor(parts: string[]) {
    super(parts);
  }
}

class FlowElementDeferredLine extends LogLine {
  declarative = true;

  constructor(parts: string[]) {
    super(parts);
    this.text = parts[2] + ' ' + parts[3];
  }
}

class FlowElementAssignmentLine extends LogLine {
  declarative = true;
  acceptsText = true;

  constructor(parts: string[]) {
    super(parts);
    this.text = parts[3] + ' ' + parts[4];
  }
}

class FlowWaitEventResumingDetailLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = `${parts[2]} : ${parts[3]} : ${parts[4]} : ${parts[5]}`;
  }
}

class FlowWaitEventWaitingDetailLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = `${parts[2]} : ${parts[3]} : ${parts[4]} : ${parts[5]} : ${parts[6]}`;
  }
}

class FlowWaitResumingDetailLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = `${parts[2]} : ${parts[3]} : ${parts[4]}`;
  }
}

class FlowWaitWaitingDetailLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = `${parts[2]} : ${parts[3]} : ${parts[4]} : ${parts[5]}`;
  }
}

class FlowInterviewFinishedLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = parts[3];
  }
}

class FlowInterviewResumedLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = `${parts[2]} : ${parts[3]}`;
  }
}

class FlowInterviewPausedLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = `${parts[2]} : ${parts[3]} : ${parts[4]}`;
  }
}

class FlowElementErrorLine extends LogLine {
  acceptsText = true;
  constructor(parts: string[]) {
    super(parts);
    this.text = parts[1] + parts[2] + ' ' + parts[3] + ' ' + parts[4];
  }
}

class FlowElementFaultLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = `${parts[2]} : ${parts[3]} : ${parts[4]}`;
  }
}

class FlowElementLimitUsageLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = `${parts[2]}`;
  }
}

class FlowInterviewFinishedLimitUsageLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = `${parts[2]}`;
  }
}

class FlowSubflowDetailLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = `${parts[2]} : ${parts[3]} : ${parts[4]} : ${parts[5]}`;
  }
}

class FlowActionCallDetailLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = parts[3] + ' : ' + parts[4] + ' : ' + parts[5] + ' : ' + parts[6];
  }
}

class FlowAssignmentDetailLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = parts[3] + ' : ' + parts[4] + ' : ' + parts[5];
  }
}

class FlowLoopDetailLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = parts[3] + ' : ' + parts[4];
  }
}

class FlowRuleDetailLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = parts[3] + ' : ' + parts[4];
  }
}

class FlowBulkElementBeginLine extends Method {
  declarative = true;

  constructor(parts: string[]) {
    super(parts, ['FLOW_BULK_ELEMENT_END'], null, 'flow', 'custom');
    this.text = `${this.type} : ${parts[2]} - ${parts[3]}`;
  }

  getBreadcrumbText(): string {
    return 'Flow';
  }
}

class FlowBulkElementEndLine extends LogLine {
  isExit = true;

  constructor(parts: string[]) {
    super(parts);
  }
}

class FlowBulkElementDetailLine extends LogLine {
  declarative = true;

  constructor(parts: string[]) {
    super(parts);
    this.text = parts[2] + ' : ' + parts[3] + ' : ' + parts[4];
  }
}

class FlowBulkElementNotSupportedLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = `${parts[2]} : ${parts[3]} : ${parts[4]}`;
  }
}

class FlowBulkElementLimitUsageLine extends LogLine {
  declarative = true;

  constructor(parts: string[]) {
    super(parts);
    this.text = parts[2];
  }
}

class PNInvalidAppLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = `${parts[2]}.${parts[3]}`;
  }
}

class PNInvalidCertificateLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = `${parts[2]}.${parts[3]}`;
  }
}
class PNInvalidNotificationLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = `${parts[2]}.${parts[3]} : ${parts[4]} : ${parts[5]} : ${parts[6]} : ${parts[7]} : ${parts[8]}`;
  }
}
class PNNoDevicesLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = `${parts[2]}.${parts[3]}`;
  }
}
class PNNotEnabledLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
  }
}
class PNSentLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = `${parts[2]}.${parts[3]} : ${parts[4]} : ${parts[5]} : ${parts[6]} : ${parts[7]}`;
  }
}

class SLAEndLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = `${parts[2]} : ${parts[3]} : ${parts[4]} : ${parts[5]} : ${parts[6]}`;
  }
}

class SLAEvalMilestoneLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = `${parts[2]}`;
  }
}

class SLANullStartDateLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
  }
}

class SLAProcessCaseLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = `${parts[2]}`;
  }
}

class TestingLimitsLine extends LogLine {
  acceptsText = true;

  constructor(parts: string[]) {
    super(parts);
  }
}

class ValidationRuleLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = parts[3];
  }
}

class ValidationErrorLine extends LogLine {
  acceptsText = true;
  constructor(parts: string[]) {
    super(parts);
    this.text = parts[2];
  }
}

class ValidationFailLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
  }
}

class ValidationFormulaLine extends LogLine {
  acceptsText = true;

  constructor(parts: string[]) {
    super(parts);
    const extra = parts.length > 3 ? ' ' + parts[3] : '';

    this.text = parts[2] + extra;
  }
}

class ValidationPassLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = parts[3];
  }
}

class WFFlowActionBeginLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
  }
}

class WFFlowActionEndLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
  }
}

class WFFlowActionErrorLine extends LogLine {
  acceptsText = true;
  constructor(parts: string[]) {
    super(parts);
    this.text = parts[1] + ' ' + parts[4];
  }
}

class WFFlowActionErrorDetailLine extends LogLine {
  acceptsText = true;
  constructor(parts: string[]) {
    super(parts);
    this.text = parts[1] + ' ' + parts[2];
  }
}

class WFFieldUpdateLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = ' ' + parts[2] + ' ' + parts[3] + ' ' + parts[4] + ' ' + parts[5] + ' ' + parts[6];
  }
}

class WFRuleEvalBeginLine extends Method {
  declarative = true;

  constructor(parts: string[]) {
    super(parts, ['WF_RULE_EVAL_END'], null, 'workflow', 'custom');
    this.text = this.type + ' : ' + parts[2];
  }

  getBreadcrumbText(): string {
    return 'WF Rule';
  }
}

class WFRuleEvalEndLine extends LogLine {
  isExit = true;

  constructor(parts: string[]) {
    super(parts);
  }
}

class WFRuleEvalValueLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = parts[2];
  }
}

class WFRuleFilterLine extends LogLine {
  acceptsText = true;

  constructor(parts: string[]) {
    super(parts);
    this.text = parts[2];
  }
}

class WFRuleNotEvaluatedLine extends LogLine {
  isExit = true;

  constructor(parts: string[]) {
    super(parts);
  }
}

class WFCriteriaBeginLine extends Method {
  declarative = true;

  constructor(parts: string[]) {
    super(parts, ['WF_CRITERIA_END', 'WF_RULE_NOT_EVALUATED'], null, 'workflow', 'custom');
    this.text = 'WF_CRITERIA : ' + parts[5] + ' : ' + parts[3];
  }

  getBreadcrumbText(): string {
    return 'WF Criteria';
  }
}

class WFCriteriaEndLine extends LogLine {
  isExit = true;

  constructor(parts: string[]) {
    super(parts);
  }
}

class WFFormulaLine extends LogLine {
  acceptsText = true;

  constructor(parts: string[]) {
    super(parts);
    this.text = parts[2] + ' : ' + parts[3];
  }
}

class WFActionLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = parts[2];
  }
}

class WFActionsEndLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = parts[2];
  }
}

class WFActionTaskLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = `${parts[2]} : ${parts[3]} : ${parts[4]} : ${parts[5]} : ${parts[6]} : ${parts[7]}`;
  }
}

class WFApprovalLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = `${parts[2]} : ${parts[3]} : ${parts[4]}`;
  }
}

class WFApprovalRemoveLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = `${parts[2]}`;
  }
}

class WFApprovalSubmitLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = `${parts[2]}`;
  }
}

class WFApprovalSubmitterLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = `${parts[2]} : ${parts[3]} : ${parts[4]}`;
  }
}

class WFAssignLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = `${parts[2]} : ${parts[3]}`;
  }
}

class WFEmailAlertLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = `${parts[2]} : ${parts[3]} : ${parts[4]}`;
  }
}

class WFEmailSentLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = `${parts[2]} : ${parts[3]} : ${parts[4]}`;
  }
}

class WFEnqueueActionsLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = parts[2];
  }
}

class WFEscalationActionLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = `${parts[2]} : ${parts[3]}`;
  }
}

class WFEscalationRuleLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
  }
}

class WFEvalEntryCriteriaLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = `${parts[2]} : ${parts[3]} : ${parts[4]}`;
  }
}

class WFFlowActionDetailLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    const optional = parts[4] ? ` : ${parts[4]} :${parts[5]}` : '';
    this.text = `${parts[2]} : ${parts[3]}` + optional;
  }
}

class WFHardRejectLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
  }
}

class WFNextApproverLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = `${parts[2]} : ${parts[3]} : ${parts[4]}`;
  }
}

class WFNoProcessFoundLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
  }
}

class WFOutboundMsgLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = `${parts[2]} : ${parts[3]} : ${parts[4]} : ${parts[5]}`;
  }
}

class WFProcessFoundLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = `${parts[2]} : ${parts[3]}`;
  }
}

class WFProcessNode extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = parts[2];
  }
}

class WFReassignRecordLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = `${parts[2]} : ${parts[3]}`;
  }
}

class WFResponseNotifyLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = `${parts[2]} : ${parts[3]} : ${parts[4]} : ${parts[5]}`;
  }
}

class WFRuleEntryOrderLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = parts[2];
  }
}

class WFRuleInvocationLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = parts[2];
  }
}

class WFSoftRejectLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = parts[2];
  }
}

class WFTimeTriggerLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = `${parts[2]} : ${parts[3]} : ${parts[4]} : ${parts[5]}`;
  }
}

class WFSpoolActionBeginLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = parts[2];
  }
}

class WFTimeTriggersBeginLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
  }
}

class ExceptionThrownLine extends LogLine {
  discontinuity = true;
  acceptsText = true;

  constructor(parts: string[]) {
    super(parts);
    const text = parts[3];
    if (text.indexOf('System.LimitException') >= 0) {
      truncateLog(this.timestamp, text, 'error');
    }

    this.lineNumber = parseLineNumber(parts[2]);
    this.text = text;
  }
}

class FatalErrorLine extends LogLine {
  acceptsText = true;
  hideable = false;
  discontinuity = true;

  constructor(parts: string[]) {
    super(parts);
    truncateLog(this.timestamp, 'FATAL ERROR! cause=' + parts[2], 'error');

    this.text = parts[2];
  }
}

class XDSDetailLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = parts[2];
  }
}

class XDSResponseLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = `${parts[2]} : ${parts[3]} : ${parts[4]} : ${parts[5]} : ${parts[6]}`;
  }
}
class XDSResponseDetailLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = parts[2];
  }
}

class XDSResponseErrorLine extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = parts[2];
  }
}

// e.g. "09:45:31.888 (38889007737)|DUPLICATE_DETECTION_BEGIN"
class DuplicateDetectionBegin extends Method {
  declarative = true;

  constructor(parts: string[]) {
    super(parts, ['DUPLICATE_DETECTION_END'], null, 'workflow', 'custom');
  }

  getBreadcrumbText(): string {
    return 'Dup';
  }
}

// e.g. "09:45:31.888 (38909459101)|DUPLICATE_DETECTION_END"
class DuplicatDetectionEnd extends LogLine {
  isExit = true;

  constructor(parts: string[]) {
    super(parts);
  }
}

// e.g. "09:45:31.888 (38889067408)|DUPLICATE_DETECTION_RULE_INVOCATION|DuplicateRuleId:0Bm20000000CaSP|DuplicateRuleName:Duplicate Account|DmlType:UPDATE"
class DuplicateDetectionRule extends LogLine {
  constructor(parts: string[]) {
    super(parts);
    this.text = `${parts[3]} - ${parts[4]}`;
  }
}

export const lineTypeMap = new Map<string, new (parts: string[]) => LogLine>([
  ['BULK_HEAP_ALLOCATE', BulkHeapAllocateLine],
  ['CALLOUT_REQUEST', CalloutRequestLine],
  ['CALLOUT_RESPONSE', CalloutResponseLine],
  ['NAMED_CREDENTIAL_REQUEST', NamedCredentialRequestLine],
  ['NAMED_CREDENTIAL_RESPONSE', NamedCredentialResponseLine],
  ['NAMED_CREDENTIAL_RESPONSE_DETAIL', NamedCredentialResponseDetailLine],
  ['CONSTRUCTOR_ENTRY', ConstructorEntryLine],
  ['CONSTRUCTOR_EXIT', ConstructorExitLine],
  ['EMAIL_QUEUE', EmailQueueLine],
  ['METHOD_ENTRY', MethodEntryLine],
  ['METHOD_EXIT', MethodExitLine],
  ['SYSTEM_CONSTRUCTOR_ENTRY', SystemConstructorEntryLine],
  ['SYSTEM_CONSTRUCTOR_EXIT', SystemConstructorExitLine],
  ['SYSTEM_METHOD_ENTRY', SystemMethodEntryLine],
  ['SYSTEM_METHOD_EXIT', SystemMethodExitLine],
  ['CODE_UNIT_STARTED', CodeUnitStartedLine],
  ['CODE_UNIT_FINISHED', CodeUnitFinishedLine],
  ['VF_APEX_CALL_START', VFApexCallStartLine],
  ['VF_APEX_CALL_END', VFApexCallEndLine],
  ['VF_DESERIALIZE_VIEWSTATE_BEGIN', VFDeserializeViewstateBeginLine],
  ['VF_DESERIALIZE_VIEWSTATE_END', VFDeserializeViewstateEndLine],
  ['VF_EVALUATE_FORMULA_BEGIN', VFFormulaStartLine],
  ['VF_EVALUATE_FORMULA_END', VFFormulaEndLine],
  ['VF_SERIALIZE_VIEWSTATE_BEGIN', VFSeralizeViewStateStartLine],
  ['VF_SERIALIZE_VIEWSTATE_END', VFSeralizeViewStateEndLine],
  ['VF_PAGE_MESSAGE', VFPageMessageLine],
  ['DML_BEGIN', DMLBeginLine],
  ['DML_END', DMLEndLine],
  ['IDEAS_QUERY_EXECUTE', IdeasQueryExecuteLine],
  ['SOQL_EXECUTE_BEGIN', SOQLExecuteBeginLine],
  ['SOQL_EXECUTE_END', SOQLExecuteEndLine],
  ['SOQL_EXECUTE_EXPLAIN', SOQLExecuteExplainLine],
  ['SOSL_EXECUTE_BEGIN', SOSLExecuteBeginLine],
  ['SOSL_EXECUTE_END', SOSLExecuteEndLine],
  ['HEAP_ALLOCATE', HeapAllocateLine],
  ['HEAP_DEALLOCATE', HeapDeallocateLine],
  ['STATEMENT_EXECUTE', StatementExecuteLine],
  ['VARIABLE_SCOPE_BEGIN', VariableScopeBeginLine],
  ['VARIABLE_SCOPE_END', VariableScopeEndLine],
  ['VARIABLE_ASSIGNMENT', VariableAssignmentLine],
  ['USER_INFO', UserInfoLine],
  ['USER_DEBUG', UserDebugLine],
  ['CUMULATIVE_LIMIT_USAGE', CumulativeLimitUsageLine],
  ['CUMULATIVE_LIMIT_USAGE_END', CumulativeLimitUsageEndLine],
  ['CUMULATIVE_PROFILING', CumulativeProfilingLine],
  ['CUMULATIVE_PROFILING_BEGIN', CumulativeProfilingBeginLine],
  ['CUMULATIVE_PROFILING_END', CumulativeProfilingEndLine],
  ['LIMIT_USAGE', LimitUsageLine],
  ['LIMIT_USAGE_FOR_NS', LimitUsageForNSLine],
  ['POP_TRACE_FLAGS', PopTraceFlagsLine],
  ['PUSH_TRACE_FLAGS', PushTraceFlagsLine],
  ['QUERY_MORE_BEGIN', QueryMoreBeginLine],
  ['QUERY_MORE_END', QueryMoreEndLine],
  ['QUERY_MORE_ITERATIONS', QueryMoreIterationsLine],
  ['TOTAL_EMAIL_RECIPIENTS_QUEUED', TotalEmailRecipientsQueuedLine],
  ['SAVEPOINT_ROLLBACK', SavepointRollbackLine],
  ['SAVEPOINT_SET', SavePointSetLine],
  ['STACK_FRAME_VARIABLE_LIST', StackFrameVariableListLine],
  ['STATIC_VARIABLE_LIST', StaticVariableListLine],
  ['SYSTEM_MODE_ENTER', SystemModeEnterLine],
  ['SYSTEM_MODE_EXIT', SystemModeExitLine],
  ['EXECUTION_STARTED', ExecutionStartedLine],
  ['EXECUTION_FINISHED', ExecutionFinishedLine],
  ['ENTERING_MANAGED_PKG', EnteringManagedPackageLine],
  ['EVENT_SERVICE_PUB_BEGIN', EventSericePubBeginLine],
  ['EVENT_SERVICE_PUB_END', EventSericePubEndLine],
  ['EVENT_SERVICE_PUB_DETAIL', EventSericePubDetailLine],
  ['EVENT_SERVICE_SUB_BEGIN', EventSericeSubBeginLine],
  ['EVENT_SERVICE_SUB_DETAIL', EventSericeSubDetailLine],
  ['EVENT_SERVICE_SUB_END', EventSericeSubEndLine],
  ['FLOW_START_INTERVIEWS_BEGIN', FlowStartInterviewsBeginLine],
  ['FLOW_START_INTERVIEWS_END', FlowStartInterviewsEndLine],
  ['FLOW_START_INTERVIEWS_ERROR', FlowStartInterviewsErrorLine],
  ['FLOW_START_INTERVIEW_BEGIN', FlowStartInterviewBeginLine],
  ['FLOW_START_INTERVIEW_END', FlowStartInterviewEndLine],
  ['FLOW_START_INTERVIEW_LIMIT_USAGE', FlowStartInterviewLimitUsageLine],
  ['FLOW_START_SCHEDULED_RECORDS', FlowStartScheduledRecordsLine],
  ['FLOW_CREATE_INTERVIEW_BEGIN', FlowCreateInterviewBeginLine],
  ['FLOW_CREATE_INTERVIEW_END', FlowCreateInterviewEndLine],
  ['FLOW_CREATE_INTERVIEW_ERROR', FlowCreateInterviewErrorLine],
  ['FLOW_ELEMENT_BEGIN', FlowElementBeginLine],
  ['FLOW_ELEMENT_END', FlowElementEndLine],
  ['FLOW_ELEMENT_DEFERRED', FlowElementDeferredLine],
  ['FLOW_ELEMENT_ERROR', FlowElementErrorLine],
  ['FLOW_ELEMENT_FAULT', FlowElementFaultLine],
  ['FLOW_ELEMENT_LIMIT_USAGE', FlowElementLimitUsageLine],
  ['FLOW_INTERVIEW_FINISHED_LIMIT_USAGE', FlowInterviewFinishedLimitUsageLine],
  ['FLOW_SUBFLOW_DETAIL', FlowSubflowDetailLine],
  ['FLOW_VALUE_ASSIGNMENT', FlowElementAssignmentLine],
  ['FLOW_WAIT_EVENT_RESUMING_DETAIL', FlowWaitEventResumingDetailLine],
  ['FLOW_WAIT_EVENT_WAITING_DETAIL', FlowWaitEventWaitingDetailLine],
  ['FLOW_WAIT_RESUMING_DETAIL', FlowWaitResumingDetailLine],
  ['FLOW_WAIT_WAITING_DETAIL', FlowWaitWaitingDetailLine],
  ['FLOW_INTERVIEW_FINISHED', FlowInterviewFinishedLine],
  ['FLOW_INTERVIEW_PAUSED', FlowInterviewPausedLine],
  ['FLOW_INTERVIEW_RESUMED', FlowInterviewResumedLine],
  ['FLOW_ACTIONCALL_DETAIL', FlowActionCallDetailLine],
  ['FLOW_ASSIGNMENT_DETAIL', FlowAssignmentDetailLine],
  ['FLOW_LOOP_DETAIL', FlowLoopDetailLine],
  ['FLOW_RULE_DETAIL', FlowRuleDetailLine],
  ['FLOW_BULK_ELEMENT_BEGIN', FlowBulkElementBeginLine],
  ['FLOW_BULK_ELEMENT_END', FlowBulkElementEndLine],
  ['FLOW_BULK_ELEMENT_DETAIL', FlowBulkElementDetailLine],
  ['FLOW_BULK_ELEMENT_LIMIT_USAGE', FlowBulkElementLimitUsageLine],
  ['FLOW_BULK_ELEMENT_NOT_SUPPORTED', FlowBulkElementNotSupportedLine],
  ['PUSH_NOTIFICATION_INVALID_APP', PNInvalidAppLine],
  ['PUSH_NOTIFICATION_INVALID_CERTIFICATE', PNInvalidCertificateLine],
  ['PUSH_NOTIFICATION_INVALID_NOTIFICATION', PNInvalidNotificationLine],
  ['PUSH_NOTIFICATION_NO_DEVICES', PNNoDevicesLine],
  ['PUSH_NOTIFICATION_NOT_ENABLED', PNNotEnabledLine],
  ['PUSH_NOTIFICATION_SENT', PNSentLine],
  ['SLA_END', SLAEndLine],
  ['SLA_EVAL_MILESTONE', SLAEvalMilestoneLine],
  ['SLA_NULL_START_DATE', SLANullStartDateLine],
  ['SLA_PROCESS_CASE', SLAProcessCaseLine],
  ['TESTING_LIMITS', TestingLimitsLine],
  ['VALIDATION_ERROR', ValidationErrorLine],
  ['VALIDATION_FAIL', ValidationFailLine],
  ['VALIDATION_FORMULA', ValidationFormulaLine],
  ['VALIDATION_PASS', ValidationPassLine],
  ['VALIDATION_RULE', ValidationRuleLine],
  ['WF_FLOW_ACTION_BEGIN', WFFlowActionBeginLine],
  ['WF_FLOW_ACTION_END', WFFlowActionEndLine],
  ['WF_FLOW_ACTION_ERROR', WFFlowActionErrorLine],
  ['WF_FLOW_ACTION_ERROR_DETAIL', WFFlowActionErrorDetailLine],
  ['WF_FIELD_UPDATE', WFFieldUpdateLine],
  ['WF_RULE_EVAL_BEGIN', WFRuleEvalBeginLine],
  ['WF_RULE_EVAL_END', WFRuleEvalEndLine],
  ['WF_RULE_EVAL_VALUE', WFRuleEvalValueLine],
  ['WF_RULE_FILTER', WFRuleFilterLine],
  ['WF_RULE_NOT_EVALUATED', WFRuleNotEvaluatedLine],
  ['WF_CRITERIA_BEGIN', WFCriteriaBeginLine],
  ['WF_CRITERIA_END', WFCriteriaEndLine],
  ['WF_FORMULA', WFFormulaLine],
  ['WF_ACTION', WFActionLine],
  ['WF_ACTIONS_END', WFActionsEndLine],
  ['WF_ACTION_TASK', WFActionTaskLine],
  ['WF_APPROVAL', WFApprovalLine],
  ['WF_APPROVAL_REMOVE', WFApprovalRemoveLine],
  ['WF_APPROVAL_SUBMIT', WFApprovalSubmitLine],
  ['WF_APPROVAL_SUBMITTER', WFApprovalSubmitterLine],
  ['WF_ASSIGN', WFAssignLine],
  ['WF_EMAIL_ALERT', WFEmailAlertLine],
  ['WF_EMAIL_SENT', WFEmailSentLine],
  ['WF_ENQUEUE_ACTIONS', WFEnqueueActionsLine],
  ['WF_ESCALATION_ACTION', WFEscalationActionLine],
  ['WF_ESCALATION_RULE', WFEscalationRuleLine],
  ['WF_EVAL_ENTRY_CRITERIA', WFEvalEntryCriteriaLine],
  ['WF_FLOW_ACTION_DETAIL', WFFlowActionDetailLine],
  ['WF_HARD_REJECT', WFHardRejectLine],
  ['WF_NEXT_APPROVER', WFNextApproverLine],
  ['WF_NO_PROCESS_FOUND', WFNoProcessFoundLine],
  ['WF_OUTBOUND_MSG', WFOutboundMsgLine],
  ['WF_PROCESS_FOUND', WFProcessFoundLine],
  ['WF_PROCESS_NODE', WFProcessNode],
  ['WF_REASSIGN_RECORD', WFReassignRecordLine],
  ['WF_RESPONSE_NOTIFY', WFResponseNotifyLine],
  ['WF_RULE_ENTRY_ORDER', WFRuleEntryOrderLine],
  ['WF_RULE_INVOCATION', WFRuleInvocationLine],
  ['WF_SOFT_REJECT', WFSoftRejectLine],
  ['WF_SPOOL_ACTION_BEGIN', WFSpoolActionBeginLine],
  ['WF_TIME_TRIGGER', WFTimeTriggerLine],
  ['WF_TIME_TRIGGERS_BEGIN', WFTimeTriggersBeginLine],
  ['EXCEPTION_THROWN', ExceptionThrownLine],
  ['FATAL_ERROR', FatalErrorLine],
  ['XDS_DETAIL', XDSDetailLine],
  ['XDS_RESPONSE', XDSResponseLine],
  ['XDS_RESPONSE_DETAIL', XDSResponseDetailLine],
  ['XDS_RESPONSE_ERROR', XDSResponseErrorLine],
  ['DUPLICATE_DETECTION_BEGIN', DuplicateDetectionBegin],
  ['DUPLICATE_DETECTION_END', DuplicatDetectionEnd],
  ['DUPLICATE_DETECTION_RULE_INVOCATION', DuplicateDetectionRule],
]);

export function parseLine(line: string, lastEntry: LogLine | null): LogLine | null {
  const parts = line.split('|'),
    type = parts[1],
    metaCtor = lineTypeMap.get(type);

  if (metaCtor) {
    const entry = new metaCtor(parts);
    entry.logLine = line;
    lastEntry?.onAfter?.(entry);
    return entry;
  }

  if (!typePattern.test(type) && lastEntry?.acceptsText) {
    // wrapped text from the previous entry?
    lastEntry.text += `\n${line}`;
  } else if (type) {
    if (type !== 'DUMMY') {
      /* Used by tests */
      console.warn(`Unknown log line: ${type}`);
    }
  } else {
    if (lastEntry && line.startsWith('*** Skipped')) {
      truncateLog(lastEntry.timestamp, 'Skipped-Lines', 'skip');
    } else if (lastEntry && line.indexOf('MAXIMUM DEBUG LOG SIZE REACHED') >= 0) {
      truncateLog(lastEntry.timestamp, 'Max-Size-reached', 'skip');
    } else if (settingsPattern.test(line)) {
      // skip an unexpected settings line
    } else {
      console.warn(`Bad log line: ${line}`);
    }
  }

  return null;
}

// Matches CRLF (\r\n) + LF (\n)
// the ? matches the previous token 0 or 1 times.
export default async function parseLog(log: string): Promise<LogLine[]> {
  const start = log.match(/^.*EXECUTION_STARTED.*$/m)?.index || -1;
  const rawLines = log.substring(start).split(newlineRegex);

  // reset global variables to be captured during parsing
  logLines = [];
  truncated = [];
  reasons = new Set<string>();
  cpuUsed = 0;
  discontinuity = false;

  let lastEntry = null;
  const len = rawLines.length;
  for (let i = 0; i < len; i++) {
    const line = rawLines[i];
    if (line) {
      // ignore blank lines
      const entry = parseLine(line, lastEntry);
      if (entry) {
        logLines.push(entry);
        lastEntry = entry;
      }
    }
  }

  return logLines;
}

export function getRootMethod() {
  const lineIter = new LineIterator(logLines),
    rootMethod = new RootNode(),
    stack: Method[] = [];
  let line: LogLine | null;

  lastTimestamp = null;
  while ((line = lineIter.fetch())) {
    line.loadContent?.(lineIter, stack);
    rootMethod.addChild(line);
  }
  rootMethod.setTimes();
  totalDuration = rootMethod.exitStamp - rootMethod.timestamp;

  insertPackageWrappers(rootMethod);
  return rootMethod;
}

function insertPackageWrappers(node: Method) {
  const children = node.children;
  let lastPkg: TimedNode | null = null;

  const newChildren = [];
  const len = children.length;
  for (let i = 0; i < len; i++) {
    const child = children[i],
      childType = child.type,
      isPkgType = childType === 'ENTERING_MANAGED_PKG';

    if (lastPkg && child instanceof TimedNode) {
      if (isPkgType && child.namespace === lastPkg.namespace) {
        // combine adjacent (like) packages
        lastPkg.exitStamp = child.exitStamp || child.timestamp;
        continue; // skip any more child processing (it's gone)
      } else if (!isPkgType) {
        // move child DML / SOQL into the last package
        if (lastPkg.children) {
          lastPkg.children.push(child); // move child into the pkg
        }

        lastPkg.totalDmlCount = child.totalDmlCount + (childType === 'DML_BEGIN' ? 1 : 0);
        lastPkg.totalSoqlCount =
          child.totalSoqlCount + (childType === 'SOQL_EXECUTE_BEGIN' ? 1 : 0);
        lastPkg.totalThrownCount =
          child.totalThrownCount + (childType === 'EXCEPTION_THROWN' ? 1 : 0);
        lastPkg.exitStamp = child.exitStamp || child.timestamp; // move the end

        if (child instanceof Method) {
          insertPackageWrappers(child);
        }
        continue; // skip any more child processing (it's moved)
      }

      lastPkg.recalculateDurations();
    }

    if (child instanceof Method) {
      insertPackageWrappers(child);
    }

    // It is a ENTERING_MANAGED_PKG line that does not match the last one
    // or we have not come across a ENTERING_MANAGED_PKG line yet.
    lastPkg = isPkgType ? (child as TimedNode) : lastPkg;
    newChildren.push(child);
  }

  lastPkg?.recalculateDurations();
  node.children = newChildren;
}

export class LogSetting {
  key: string;
  level: string;

  constructor(key: string, level: string) {
    this.key = key;
    this.level = level;
  }
}

export function getLogSettings(log: string) {
  const match = log.match(settingsPattern);
  if (!match) {
    return [];
  }

  const settings = match[0],
    settingList = settings.substring(settings.indexOf(' ') + 1).split(';');

  return settingList.map((entry) => {
    const parts = entry.split(',');
    return new LogSetting(parts[0], parts[1]);
  });
}

export { logLines, totalDuration, truncated, cpuUsed };
export { SOQLExecuteExplainLine, SOQLExecuteBeginLine, DMLBeginLine };
