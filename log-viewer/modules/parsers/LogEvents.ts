/*
 * Copyright (c) 2020 Certinia Inc. All rights reserved.
 */

import type { ApexLogParser, DebugLevel } from './ApexLogParser';
import type {
  CPUType,
  GovernorLimits,
  Limits,
  LineNumber,
  LogEventType,
  LogIssue,
  LogSubCategory,
  SelfTotal,
} from './types.js';

/**
 * All log lines extend this base class.
 */
export abstract class LogEvent {
  logParser: ApexLogParser;

  // common metadata (available for all lines)

  parent: LogEvent | null = null;

  /**
   * All child nodes of the current node
   */
  children: LogEvent[] = [];

  /**
   * The type of this log line from the log file e.g METHOD_ENTRY
   */
  type: LogEventType | null = null;

  /**
   * The full raw text of this log line
   */
  logLine = ''; // the raw text of this log line

  /**
   * A parsed version of the log line text useful for display in UIs
   */
  text;

  // optional metadata
  /**
   * Should this log entry pull in following text lines (as the log entry can contain newlines)?
   */
  acceptsText = false;

  /**
   * Is this log entry generated by a declarative process?
   */
  declarative = false;
  /**
   * Is a method exit line?
   */
  isExit = false;

  /**
   * Whether the log event was truncated when the log ended, e,g no matching end event
   */
  isTruncated = false;

  /**
   * Should the exitstamp be the timestamp of the next line?
   * These kind of lines can not be used as exit lines for anything othe than other pseudo exits.
   */
  nextLineIsExit = false;

  /**
   * The line number within the containing class
   */
  lineNumber: LineNumber = null;

  /**
   * The package namespace associated with this log line
   * @default default
   */
  namespace: string | 'default' = '';

  /**
   * The variable value
   */
  value: string | null = null;

  /**
   * Could match to a corresponding symbol in a file in the workspace?
   */
  hasValidSymbols = false;

  /**
   * Extra description context
   */
  suffix: string | null = null;

  /**
   * Does this line cause a discontinuity in the call stack? e.g an exception causing stack unwinding
   */
  discontinuity = false;

  /**
   * The timestamp of this log line, in nanoseconds
   */
  timestamp;

  /**
   * The timestamp when the node finished, in nanoseconds
   */
  exitStamp: number | null = null;

  /**
   * The log sub category this event belongs to
   */
  subCategory: LogSubCategory = '';

  /**
   * The CPU type, e.g loading, method, custom
   */
  cpuType: CPUType = ''; // the category key to collect our cpu usage

  /**
   * The time spent.
   */
  duration: SelfTotal = {
    /**
     * The net (wall) time spent in the node (when not inside children)
     */
    self: 0,
    /**
     * The total (wall) time spent in the node
     */
    total: 0,
  };

  /**
   * Total + self row counts for DML
   */
  dmlRowCount: SelfTotal = {
    /**
     * The net number of DML rows for this node, excluding child nodes
     */
    self: 0,
    /**
     * The total number of DML rows for this node and child nodes
     */
    total: 0,
  };

  /**
   * Total + self row counts for SOQL
   */
  soqlRowCount: SelfTotal = {
    /**
     * The net number of SOQL rows for this node, excluding child nodes
     */
    self: 0,
    /**
     * The total number of SOQL rows for this node and child nodes
     */
    total: 0,
  };

  /**
   * Total + self row counts for SOSL
   */
  soslRowCount: SelfTotal = {
    /**
     * The net number of SOSL rows for this node, excluding child nodes
     */
    self: 0,
    /**
     * The total number of SOSL rows for this node and child nodes
     */
    total: 0,
  };

  dmlCount: SelfTotal = {
    /**
     * The net number of DML operations (DML_BEGIN) in this node.
     */
    self: 0,
    /**
     * The total number of DML operations (DML_BEGIN) in this node and child nodes
     */
    total: 0,
  };

  soqlCount: SelfTotal = {
    /**
     * The net number of SOQL operations (SOQL_EXECUTE_BEGIN) in this node.
     */
    self: 0,
    /**
     * The total number of SOQL operations (SOQL_EXECUTE_BEGIN) in this node and child nodes
     */
    total: 0,
  };

  soslCount: SelfTotal = {
    /**
     * The net number of SOSL operations (SOSL_EXECUTE_BEGIN) in this node.
     */
    self: 0,
    /**
     * The total number of SOSL operations (SOSL_EXECUTE_BEGIN) in this node and child nodes
     */
    total: 0,
  };

  /**
   * The total number of exceptions thrown (EXCEPTION_THROWN) in this node and child nodes
   */
  totalThrownCount = 0;

  /**
   * The line types which would legitimately end this method
   */
  exitTypes: LogEventType[] = [];

  constructor(parser: ApexLogParser, parts: string[] | null) {
    this.logParser = parser;
    if (parts) {
      const [timeData, type] = parts;
      this.text = this.type = type as LogEventType;
      this.timestamp = timeData ? this.parseTimestamp(timeData) : 0;
    } else {
      this.timestamp = 0;
      this.text = '';
    }
  }

  /** Called if a corresponding end event is found during tree parsing*/
  onEnd?(end: LogEvent, stack: LogEvent[]): void;

  /** Called when the Log event after this one is created in the line parser*/
  onAfter?(parser: ApexLogParser, next?: LogEvent): void;

  public recalculateDurations() {
    if (this.exitStamp) {
      this.duration.total = this.duration.self = this.exitStamp - this.timestamp;
    }
  }

  private parseTimestamp(text: string): number {
    const start = text.indexOf('(');
    if (start !== -1) {
      return Number(text.slice(start + 1, -1));
    }
    throw new Error(`Unable to parse timestamp: '${text}'`);
  }

  protected parseLineNumber(text: string | null | undefined): LineNumber {
    switch (true) {
      case text === '[EXTERNAL]':
        return 'EXTERNAL';
      case !!text: {
        const lineNumberStr = text.slice(1, -1);
        if (lineNumberStr) {
          return Number(lineNumberStr);
        }
        throw new Error(`Unable to parse line number: '${text}'`);
      }
      default:
        return 0;
    }
  }
}

export class BasicLogLine extends LogEvent {}
export class BasicExitLine extends LogEvent {
  isExit = true;
}

/**
 * Log lines extend this export class if they have a start-line and an end-line (and hence can have children in-between).
 * - The start-line should extend "Method" and collect any children.
 * - The end-line should extend "Detail" and terminate the method (also providing the "exitStamp").
 * The method will be rendered as "expandable" in the tree-view, if it has children.
 */
export class Method extends LogEvent {
  constructor(
    parser: ApexLogParser,
    parts: string[] | null,
    exitTypes: string[],
    timelineKey: LogSubCategory,
    cpuType: CPUType,
  ) {
    super(parser, parts);
    this.subCategory = timelineKey;
    this.cpuType = cpuType;
    this.exitTypes = exitTypes as LogEventType[];
  }
}

/**
 * This export class represents the single root node for the node tree.
 * It is a "pseudo" node and not present in the log.
 * Since it has children it extends "Method".
 */
export class ApexLog extends Method {
  type = null;
  text = 'LOG_ROOT';
  timestamp = 0;
  exitStamp = 0;
  /**
   * The size of the log, in bytes
   */
  public size = 0;

  /**
   * The Apex Debug Logging Levels for the current log
   */
  public debugLevels: DebugLevel[] = [];

  /**
   * All the namespaces that appear in this log.
   */
  public namespaces: string[] = [];

  /**
   * Any issues within the log, such as cpu time exceeded or max log size reached.
   */
  public logIssues: LogIssue[] = [];

  /**
   * Any issues that occurred during the parsing of the log, such as an unrecognized log event type.
   */
  public parsingErrors: string[] = [];

  public governorLimits: GovernorLimits = {
    soqlQueries: { used: 0, limit: 0 },
    soslQueries: { used: 0, limit: 0 },
    queryRows: { used: 0, limit: 0 },
    dmlStatements: { used: 0, limit: 0 },
    publishImmediateDml: { used: 0, limit: 0 },
    dmlRows: { used: 0, limit: 0 },
    cpuTime: { used: 0, limit: 0 },
    heapSize: { used: 0, limit: 0 },
    callouts: { used: 0, limit: 0 },
    emailInvocations: { used: 0, limit: 0 },
    futureCalls: { used: 0, limit: 0 },
    queueableJobsAddedToQueue: { used: 0, limit: 0 },
    mobileApexPushCalls: { used: 0, limit: 0 },
    byNamespace: new Map<string, Limits>(),
  };

  /**
   * The endtime with nodes of 0 duration excluded
   */
  executionEndTime = 0;

  constructor(parser: ApexLogParser) {
    super(parser, null, [], 'Code Unit', '');
  }

  setTimes() {
    this.timestamp =
      this.children.find((child) => {
        return child.timestamp;
      })?.timestamp || 0;
    // We do not just want to use the very last exitStamp because it could be CUMULATIVE_USAGE which is not really part of the code execution time but does have a later time.
    let endTime;
    const reverseLen = this.children.length - 1;
    for (let i = reverseLen; i >= 0; i--) {
      const child = this.children[i];
      // If there is no duration on a node then it is not going to be shown on the timeline anyway
      if (child?.exitStamp) {
        endTime ??= child.exitStamp;
        if (child.duration) {
          this.executionEndTime = child.exitStamp;
          break;
        }
      }
      endTime ??= child?.timestamp;
    }
    this.exitStamp = endTime || 0;
    this.recalculateDurations();
  }
}

export function parseObjectNamespace(text: string | null | undefined): string {
  if (!text) {
    return '';
  }

  const sep = text.indexOf('__');
  if (sep === -1) {
    return 'default';
  }
  return text.slice(0, sep);
}

export function parseVfNamespace(text: string): string {
  const sep = text.indexOf('__');
  if (sep === -1) {
    return 'default';
  }
  const firstSlash = text.indexOf('/');
  if (firstSlash === -1) {
    return 'default';
  }
  const secondSlash = text.indexOf('/', firstSlash + 1);
  if (secondSlash < 0) {
    return 'default';
  }
  return text.substring(secondSlash + 1, sep);
}

export function parseRows(text: string | null | undefined): number {
  if (!text) {
    return 0;
  }

  const rowCount = text.slice(text.indexOf('Rows:') + 5);
  if (rowCount) {
    return Number(rowCount);
  }
  throw new Error(`Unable to parse row count: '${text}'`);
}

/* Log line entry Parsers */

export class BulkHeapAllocateLine extends LogEvent {
  logCategory: 'Apex Code';
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = parts[2] || '';
    this.logCategory = 'Apex Code';
  }
}

export class CalloutRequestLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = `${parts[3]} : ${parts[2]}`;
  }
}

export class CalloutResponseLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = `${parts[3]} : ${parts[2]}`;
  }
}
export class NamedCredentialRequestLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = `${parts[3]} : ${parts[4]} : ${parts[5]} : ${parts[6]}`;
  }
}

export class NamedCredentialResponseLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = `${parts[2]}`;
  }
}

export class NamedCredentialResponseDetailLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = `${parts[3]} : ${parts[4]} ${parts[5]} : ${parts[6]} ${parts[7]}`;
  }
}

export class ConstructorEntryLine extends Method {
  hasValidSymbols = true;
  suffix = ' (constructor)';

  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts, ['CONSTRUCTOR_EXIT'], 'Method', 'method');
    this.lineNumber = this.parseLineNumber(parts[2]);
    const [, , , , args, className] = parts;

    this.text = className + (args ? args.substring(args.lastIndexOf('(')) : '');
    const possibleNS = this._parseConstructorNamespace(className || '');
    if (possibleNS) {
      this.namespace = possibleNS;
    }
  }

  _parseConstructorNamespace(className: string): string {
    let possibleNs = className.slice(0, className.indexOf('.'));
    if (this.logParser.namespaces.has(possibleNs)) {
      return possibleNs;
    }

    const constructorParts = (className ?? '').split('.');
    possibleNs = constructorParts[0] || '';
    // inmner export class with a namespace
    if (constructorParts.length === 3) {
      return possibleNs;
    }

    return '';
  }
}

export class ConstructorExitLine extends LogEvent {
  isExit = true;

  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.lineNumber = this.parseLineNumber(parts[2]);
  }
}

export class EmailQueueLine extends LogEvent {
  acceptsText = true;
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.lineNumber = this.parseLineNumber(parts[2]);
  }
}

export class MethodEntryLine extends Method {
  hasValidSymbols = true;

  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts, ['METHOD_EXIT'], 'Method', 'method');
    this.lineNumber = this.parseLineNumber(parts[2]);
    this.text = parts[4] || this.type || this.text;
    if (this.text.indexOf('System.Type.forName(') !== -1) {
      // assume we are not charged for export class loading (or at least not lengthy remote-loading / compiling)
      this.cpuType = 'loading';
    } else {
      const possibleNs = this._parseMethodNamespace(parts[4]);
      if (possibleNs) {
        this.namespace = possibleNs;
      }
    }
  }

  onEnd(end: MethodExitLine, _stack: LogEvent[]): void {
    if (end.namespace && !end.text.endsWith(')')) {
      this.namespace = end.namespace;
    }
  }

  _parseMethodNamespace(methodName: string | undefined): string {
    if (!methodName) {
      return '';
    }

    const methodBracketIndex = methodName.indexOf('(');
    if (methodBracketIndex === -1) {
      return '';
    }

    const nsSeparator = methodName.indexOf('.');
    if (nsSeparator === -1) {
      return '';
    }

    const possibleNs = methodName.slice(0, nsSeparator);
    if (this.logParser.namespaces.has(possibleNs)) {
      return possibleNs;
    }

    const methodNameParts = methodName.slice(0, methodBracketIndex)?.split('.');
    if (methodNameParts.length === 4) {
      return methodNameParts[0] ?? '';
    } else if (methodNameParts.length === 2) {
      return 'default';
    }

    return '';
  }
}
export class MethodExitLine extends LogEvent {
  isExit = true;

  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.lineNumber = this.parseLineNumber(parts[2]);
    this.text = parts[4] ?? parts[3] ?? this.text;

    /*A method will end with ')'. Without that this it represents the first reference to a class, outer or inner. One of the few reliable ways to determine valid namespaces. The first reference to a class (outer or inner) will always have an METHOD_EXIT containing the Outer class name with namespace if present. Other events will follow, CONSTRUCTOR_ENTRY etc. But this case will only ever have 2 parts ns.Outer even if the first reference was actually an inner class e.g new ns.Outer.Inner();*/
    // If does not end in ) then we have a reference to the class, either via outer or inner.
    if (!this.text.endsWith(')')) {
      // if there is a . the we have a namespace e.g ns.Outer
      const index = this.text.indexOf('.');
      if (index !== -1) {
        this.namespace = this.text.slice(0, index);
      }
    }
  }
}

export class SystemConstructorEntryLine extends Method {
  suffix = '(system constructor)';

  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts, ['SYSTEM_CONSTRUCTOR_EXIT'], 'System Method', 'method');
    this.lineNumber = this.parseLineNumber(parts[2]);
    this.text = parts[3] || '';
  }
}

export class SystemConstructorExitLine extends LogEvent {
  isExit = true;

  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.lineNumber = this.parseLineNumber(parts[2]);
  }
}
export class SystemMethodEntryLine extends Method {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts, ['SYSTEM_METHOD_EXIT'], 'System Method', 'method');
    this.lineNumber = this.parseLineNumber(parts[2]);
    this.text = parts[3] || '';
  }
}

export class SystemMethodExitLine extends LogEvent {
  isExit = true;

  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.lineNumber = this.parseLineNumber(parts[2]);
  }
}

export class CodeUnitStartedLine extends Method {
  suffix = ' (entrypoint)';
  codeUnitType = '';

  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts, ['CODE_UNIT_FINISHED'], 'Code Unit', 'custom');

    const typeString = parts[5] || parts[4] || parts[3] || '';
    let sepIndex = typeString.indexOf(':');
    if (sepIndex === -1) {
      sepIndex = typeString.indexOf('/');
    }
    this.codeUnitType = sepIndex !== -1 ? typeString.slice(0, sepIndex) : '';

    const name = parts[4] || parts[3] || this.codeUnitType || '';
    switch (this.codeUnitType) {
      case 'EventService':
        this.cpuType = 'method';
        this.namespace = parseObjectNamespace(typeString.slice(sepIndex + 1));
        this.text = name;
        break;
      case 'Validation':
        this.cpuType = 'custom';
        this.declarative = true;

        this.text = name;
        break;
      case 'Workflow':
        this.cpuType = 'custom';
        this.declarative = true;
        this.text = name;
        break;
      case 'Flow':
        this.cpuType = 'custom';
        this.declarative = true;
        this.text = name;
        break;
      case 'VF':
        this.cpuType = 'method';
        this.namespace = parseVfNamespace(name);
        this.text = name;
        break;
      case 'apex': {
        this.cpuType = 'method';
        const namespaceIndex = name.indexOf('.');
        this.namespace =
          namespaceIndex !== -1
            ? name.slice(name.indexOf('apex://') + 7, namespaceIndex)
            : 'default';
        this.text = name;
        break;
      }
      case '__sfdc_trigger': {
        this.cpuType = 'method';
        this.text = name || parts[4] || '';
        const triggerParts = parts[5]?.split('/') || '';
        this.namespace = triggerParts.length === 3 ? triggerParts[1] || 'default' : 'default';
        break;
      }
      default: {
        this.cpuType = 'method';
        this.text = name;
        const openBracket = name.lastIndexOf('(');
        const methodName =
          openBracket !== -1 ? name.slice(0, openBracket + 1).split('.') : name.split('.');
        if (methodName.length === 3 || (methodName.length === 2 && !methodName[1]?.endsWith('('))) {
          this.namespace = methodName[0] || 'default';
        }
        break;
      }
    }

    this.namespace ||= 'default';
  }
}
export class CodeUnitFinishedLine extends LogEvent {
  isExit = true;

  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = parts[2] || '';
  }
}

export class VFApexCallStartLine extends Method {
  suffix = ' (VF APEX)';
  invalidClasses = [
    'pagemessagescomponentcontroller',
    'pagemessagecomponentcontroller',
    'severitymessages',
  ];

  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts, ['VF_APEX_CALL_END'], 'Method', 'method');
    this.lineNumber = this.parseLineNumber(parts[2]);

    const classText = parts[5] || parts[3] || '';
    let methodtext = parts[4] || '';
    if (
      !methodtext &&
      (!classText.includes(' ') ||
        this.invalidClasses.some((invalidCls: string) =>
          classText.toLowerCase().includes(invalidCls),
        ))
    ) {
      // we have a system entry and they do not have exits
      // e.g |VF_APEX_CALL_START|[EXTERNAL]|/apexpage/pagemessagescomponentcontroller.apex <init>
      // and they really mess with the logs so skip handling them.
      this.exitTypes = [];
    } else if (methodtext) {
      this.hasValidSymbols = true;
      // method call
      const methodIndex = methodtext.indexOf('(');
      const constructorIndex = methodtext.indexOf('<init>');
      if (methodIndex > -1) {
        // Method
        methodtext = '.' + methodtext.substring(methodIndex).slice(1, -1) + '()';
      } else if (constructorIndex > -1) {
        // Constructor
        methodtext = methodtext.substring(constructorIndex + 6) + '()';
      } else {
        // Property
        methodtext = '.' + methodtext;
      }
    } else {
      this.hasValidSymbols = true;
    }
    this.text = classText + methodtext;
  }
}

export class VFApexCallEndLine extends LogEvent {
  isExit = true;

  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = parts[2] || '';
  }
}

export class VFDeserializeViewstateBeginLine extends Method {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts, ['VF_DESERIALIZE_VIEWSTATE_END'], 'System Method', 'method');
  }
}

export class VFFormulaStartLine extends Method {
  suffix = ' (VF FORMULA)';

  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts, ['VF_EVALUATE_FORMULA_END'], 'System Method', 'custom');
    this.text = parts[3] || '';
  }
}

export class VFFormulaEndLine extends LogEvent {
  isExit = true;

  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = parts[2] || '';
  }
}

export class VFSeralizeViewStateStartLine extends Method {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts, ['VF_SERIALIZE_VIEWSTATE_END'], 'System Method', 'method');
  }
}

export class VFPageMessageLine extends LogEvent {
  acceptsText = true;
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = parts[2] || '';
  }
}

export class DMLBeginLine extends Method {
  dmlCount = {
    self: 1,
    total: 1,
  };

  namespace = 'default';

  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts, ['DML_END'], 'DML', 'free');
    this.lineNumber = this.parseLineNumber(parts[2]);
    this.text = 'DML ' + parts[3] + ' ' + parts[4];
    const rowCountString = parts[5];
    this.dmlRowCount.total = this.dmlRowCount.self = rowCountString ? parseRows(rowCountString) : 0;
  }
}

export class DMLEndLine extends LogEvent {
  isExit = true;

  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.lineNumber = this.parseLineNumber(parts[2]);
  }
}

export class IdeasQueryExecuteLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.lineNumber = this.parseLineNumber(parts[2]);
  }
}

export class SOQLExecuteBeginLine extends Method {
  aggregations = 0;
  soqlCount = {
    self: 1,
    total: 1,
  };

  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts, ['SOQL_EXECUTE_END'], 'SOQL', 'free');
    this.lineNumber = this.parseLineNumber(parts[2]);

    const [, , , aggregations, soqlString] = parts;

    const aggregationText = aggregations || '';
    if (aggregationText) {
      const aggregationIndex = aggregationText.indexOf('Aggregations:');
      this.aggregations = Number(aggregationText.slice(aggregationIndex + 13));
    }
    this.text = soqlString || '';
  }

  onEnd(end: SOQLExecuteEndLine, _stack: LogEvent[]): void {
    this.soqlRowCount.total = this.soqlRowCount.self = end.soqlRowCount.total;
  }
}

export class SOQLExecuteEndLine extends LogEvent {
  isExit = true;

  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.lineNumber = this.parseLineNumber(parts[2]);
    this.soqlRowCount.total = this.soqlRowCount.self = parseRows(parts[3] || '');
  }
}

export class SOQLExecuteExplainLine extends LogEvent {
  cardinality: number | null = null; // The estimated number of records that the leading operation type would return
  fields: string[] | null = null; //The indexed field(s) used by the Query Optimizer. If the leading operation type is Index, the fields value is Index. Otherwise, the fields value is null.
  leadingOperationType: string | null = null; // The primary operation type that Salesforce will use to optimize the query.
  relativeCost: number | null = null; // The cost of the query compared to the Force.com Query Optimizer’s selectivity threshold. Values above 1 mean that the query won’t be selective.
  sObjectCardinality: number | null = null; // The approximate record count for the queried object.
  sObjectType: string | null = null; //T he name of the queried SObject

  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.lineNumber = this.parseLineNumber(parts[2]);

    const queryPlanDetails = parts[3] || '';
    this.text = queryPlanDetails;

    const queryplanParts = queryPlanDetails.split('],');
    if (queryplanParts.length > 1) {
      const planExplain = queryplanParts[0] || '';
      const [cardinalityText, sobjCardinalityText, costText] = (queryplanParts[1] || '').split(',');

      const onIndex = planExplain.indexOf(' on');
      this.leadingOperationType = planExplain.slice(0, onIndex);

      const colonIndex = planExplain.indexOf(' :');
      this.sObjectType = planExplain.slice(onIndex + 4, colonIndex);

      // remove whitespace if there is any. we could have [ field1__c, field2__c ]
      // I am not 100% sure of format when we have multiple fields so this is safer
      const fieldsAsString = planExplain.slice(planExplain.indexOf('[') + 1).replace(/\s+/g, '');
      this.fields = fieldsAsString === '' ? [] : fieldsAsString.split(',');

      this.cardinality = cardinalityText
        ? Number(cardinalityText.slice(cardinalityText.indexOf('cardinality: ') + 13))
        : null;
      this.sObjectCardinality = sobjCardinalityText
        ? Number(
            sobjCardinalityText.slice(sobjCardinalityText.indexOf('sobjectCardinality: ') + 20),
          )
        : null;
      this.relativeCost = costText
        ? Number(costText.slice(costText.indexOf('relativeCost ') + 13))
        : null;
    }
  }
}

export class SOSLExecuteBeginLine extends Method {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts, ['SOSL_EXECUTE_END'], 'SOQL', 'free');
    this.lineNumber = this.parseLineNumber(parts[2]);
    this.text = `SOSL: ${parts[3]}`;

    this.soslCount = {
      self: 1,
      total: 1,
    };
  }

  onEnd(end: SOSLExecuteEndLine, _stack: LogEvent[]): void {
    this.soslRowCount.total = this.soslRowCount.self = end.soslRowCount.total;
  }
}

export class SOSLExecuteEndLine extends LogEvent {
  isExit = true;

  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.lineNumber = this.parseLineNumber(parts[2]);
    this.soslRowCount.total = this.soslRowCount.self = parseRows(parts[3] || '');
  }
}

export class HeapAllocateLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.lineNumber = this.parseLineNumber(parts[2]);
    this.text = parts[3] || '';
  }
}

export class HeapDeallocateLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.lineNumber = this.parseLineNumber(parts[2]);
  }
}

export class StatementExecuteLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.lineNumber = this.parseLineNumber(parts[2]);
  }
}

export class VariableScopeBeginLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.lineNumber = this.parseLineNumber(parts[2]);
    this.text = parts.slice(3).join(' | ');
  }
}

export class VariableAssignmentLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.lineNumber = this.parseLineNumber(parts[2]);
    this.text = parts.slice(3).join(' | ');
  }
}
export class UserInfoLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.lineNumber = this.parseLineNumber(parts[2]);
    this.text = parts[3] + ' ' + parts[4];
  }
}

export class UserDebugLine extends LogEvent {
  acceptsText = true;

  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.lineNumber = this.parseLineNumber(parts[2]);
    this.text = parts.slice(3).join(' | ');
  }
}

export class CumulativeLimitUsageLine extends Method {
  namespace = 'default';
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts, ['CUMULATIVE_LIMIT_USAGE_END'], 'System Method', 'system');
  }
}

export class CumulativeProfilingLine extends LogEvent {
  acceptsText = true;
  namespace = 'default';
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = parts[2] + ' ' + (parts[3] ?? '');
  }
}

export class CumulativeProfilingBeginLine extends Method {
  namespace = 'default';
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts, ['CUMULATIVE_PROFILING_END'], 'System Method', 'custom');
  }
}

export class LimitUsageLine extends LogEvent {
  namespace = 'default';
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.lineNumber = this.parseLineNumber(parts[2]);
    this.text = parts[3] + ' ' + parts[4] + ' out of ' + parts[5];
  }
}

export class LimitUsageForNSLine extends LogEvent {
  static limitsKeys = new Map<string, string>([
    ['Number of SOQL queries', 'soqlQueries'],
    ['Number of query rows', 'queryRows'],
    ['Number of SOSL queries', 'soslQueries'],
    ['Number of DML statements', 'dmlStatements'],
    ['Number of Publish Immediate DML', 'publishImmediateDml'],
    ['Number of DML rows', 'dmlRows'],
    ['Maximum CPU time', 'cpuTime'],
    ['Maximum heap size', 'heapSize'],
    ['Number of callouts', 'callouts'],
    ['Number of Email Invocations', 'emailInvocations'],
    ['Number of future calls', 'futureCalls'],
    ['Number of queueable jobs added to the queue', 'queueableJobsAddedToQueue'],
    ['Number of Mobile Apex push calls', 'mobileApexPushCalls'],
  ]);

  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.acceptsText = true;
    this.namespace = 'default';

    this.text = parts[2] || '';
  }

  onAfter(parser: ApexLogParser, _next?: LogEvent): void {
    // Parse the namespace from the first line (before any newline)
    this.namespace = this.text.slice(0, this.text.indexOf('\n')).replace(/\(|\)/g, '');

    // Clean up the text for easier parsing
    const cleanedText = this.text
      .replace(/^\s+/gm, '')
      .replaceAll('******* CLOSE TO LIMIT', '')
      .replaceAll(' out of ', '/');
    this.text = cleanedText;

    // Split into lines and parse each line for limits
    const lines = cleanedText.split('\n');
    const limits: Limits = {
      soqlQueries: { used: 0, limit: 0 },
      soslQueries: { used: 0, limit: 0 },
      queryRows: { used: 0, limit: 0 },
      dmlStatements: { used: 0, limit: 0 },
      publishImmediateDml: { used: 0, limit: 0 },
      dmlRows: { used: 0, limit: 0 },
      cpuTime: { used: 0, limit: 0 },
      heapSize: { used: 0, limit: 0 },
      callouts: { used: 0, limit: 0 },
      emailInvocations: { used: 0, limit: 0 },
      futureCalls: { used: 0, limit: 0 },
      queueableJobsAddedToQueue: { used: 0, limit: 0 },
      mobileApexPushCalls: { used: 0, limit: 0 },
    };

    for (const line of lines) {
      // Match lines like: "Maximum CPU time: 15008/10000"
      const match = line.match(/^(.+?):\s*([\d,]+)\/([\d,]+)/);
      if (match) {
        const key: keyof Limits = LimitUsageForNSLine.limitsKeys.get(
          match[1]!.trim(),
        ) as keyof Limits;
        if (key) {
          const used = parseInt(match[2]!.replace(/,/g, ''), 10);
          const limit = parseInt(match[3]!.replace(/,/g, ''), 10);
          if (key) {
            limits[key] = { used, limit };
          }
        }
      }
    }

    parser.governorLimits.byNamespace.set(this.namespace, limits);
  }
}

export class NBANodeBegin extends Method {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts, ['NBA_NODE_END'], 'System Method', 'method');
    this.text = parts.slice(2).join(' | ');
  }
}

export class NBANodeDetail extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = parts.slice(2).join(' | ');
  }
}
export class NBANodeEnd extends LogEvent {
  isExit = true;
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = parts.slice(2).join(' | ');
  }
}
export class NBANodeError extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = parts.slice(2).join(' | ');
  }
}
export class NBAOfferInvalid extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = parts.slice(2).join(' | ');
  }
}
export class NBAStrategyBegin extends Method {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts, ['NBA_STRATEGY_END'], 'System Method', 'method');
    this.text = parts.slice(2).join(' | ');
  }
}
export class NBAStrategyEnd extends LogEvent {
  isExit = true;
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = parts.slice(2).join(' | ');
  }
}
export class NBAStrategyError extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = parts.slice(2).join(' | ');
  }
}

export class PushTraceFlagsLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.lineNumber = this.parseLineNumber(parts[2]);
    this.text = parts[4] + ', line:' + this.lineNumber + ' - ' + parts[5];
  }
}

export class PopTraceFlagsLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.lineNumber = this.parseLineNumber(parts[2]);
    this.text = parts[4] + ', line:' + this.lineNumber + ' - ' + parts[5];
  }
}

export class QueryMoreBeginLine extends Method {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts, ['QUERY_MORE_END'], 'SOQL', 'custom');
    this.lineNumber = this.parseLineNumber(parts[2]);
    this.text = `line: ${this.lineNumber}`;
  }
}

export class QueryMoreEndLine extends LogEvent {
  isExit = true;

  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.lineNumber = this.parseLineNumber(parts[2]);
    this.text = `line: ${this.lineNumber}`;
  }
}
export class QueryMoreIterationsLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.lineNumber = this.parseLineNumber(parts[2]);
    this.text = `line: ${this.lineNumber}, iterations:${parts[3]}`;
  }
}

export class SavepointRollbackLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.lineNumber = this.parseLineNumber(parts[2]);
    this.text = `${parts[3]}, line: ${this.lineNumber}`;
  }
}

export class SavePointSetLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.lineNumber = this.parseLineNumber(parts[2]);
    this.text = `${parts[3]}, line: ${this.lineNumber}`;
  }
}

export class TotalEmailRecipientsQueuedLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = parts[2] || '';
  }
}

export class StackFrameVariableListLine extends LogEvent {
  acceptsText = true;

  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
  }
}

export class StaticVariableListLine extends LogEvent {
  acceptsText = true;

  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
  }
}

// This looks like a method, but the exit line is often missing...
export class SystemModeEnterLine extends LogEvent {
  // namespace = "system";

  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = parts[2] || '';
  }
}

export class SystemModeExitLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = parts[2] || '';
  }
}

export class ExecutionStartedLine extends Method {
  namespace = 'default';
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts, ['EXECUTION_FINISHED'], 'Method', 'method');
  }
}

export class EnteringManagedPackageLine extends Method {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts, [], 'Method', 'pkg');
    const rawNs = parts[2] || '',
      lastDot = rawNs.lastIndexOf('.');

    this.text = this.namespace = lastDot < 0 ? rawNs : rawNs.substring(lastDot + 1);
  }

  onAfter(parser: ApexLogParser, end?: LogEvent): void {
    if (end) {
      this.exitStamp = end.timestamp;
    }
  }
}

export class EventSericePubBeginLine extends Method {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts, ['EVENT_SERVICE_PUB_END'], 'Flow', 'custom');
    this.text = parts[2] || '';
  }
}

export class EventSericePubEndLine extends LogEvent {
  isExit = true;

  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = parts[2] || '';
  }
}

export class EventSericePubDetailLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = parts[2] + ' ' + parts[3] + ' ' + parts[4];
  }
}

export class EventSericeSubBeginLine extends Method {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts, ['EVENT_SERVICE_SUB_END'], 'Flow', 'custom');
    this.text = `${parts[2]} ${parts[3]}`;
  }
}

export class EventSericeSubEndLine extends LogEvent {
  isExit = true;

  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = `${parts[2]} ${parts[3]}`;
  }
}

export class EventSericeSubDetailLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = `${parts[2]} ${parts[3]} ${parts[4]} ${parts[6]} ${parts[6]}`;
  }
}

export class FlowStartInterviewsBeginLine extends Method {
  declarative = true;
  text = 'FLOW_START_INTERVIEWS : ';

  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts, ['FLOW_START_INTERVIEWS_END'], 'Flow', 'custom');
  }

  onEnd(end: LogEvent, stack: LogEvent[]) {
    const flowType = this.getFlowType(stack);
    this.suffix = ` (${flowType})`;
    this.text += this.getFlowName();
  }

  getFlowType(stack: LogEvent[]) {
    let flowType;
    // ignore the last one on stack is it will be this FlowStartInterviewsBeginLine
    const len = stack.length - 2;
    for (let i = len; i >= 0; i--) {
      const elem = stack[i];
      // type = "CODE_UNIT_STARTED" a flow or Processbuilder was started directly
      // type = "FLOW_START_INTERVIEWS_BEGIN" a flow was started from a process builder
      if (elem instanceof CodeUnitStartedLine) {
        flowType = elem.codeUnitType === 'Flow' ? 'Flow' : 'Process Builder';
        break;
      } else if (elem && elem.type === 'FLOW_START_INTERVIEWS_BEGIN') {
        flowType = 'Flow';
        break;
      }
    }
    return flowType || '';
  }

  getFlowName() {
    if (this.children.length) {
      return this.children[0]?.text || '';
    }
    return '';
  }
}

export class FlowStartInterviewsErrorLine extends LogEvent {
  acceptsText = true;
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = `${parts[2]} - ${parts[4]}`;
  }
}

export class FlowStartInterviewBeginLine extends Method {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts, ['FLOW_START_INTERVIEW_END'], 'Flow', 'custom');
    this.text = parts[3] || '';
  }
}

export class FlowStartInterviewLimitUsageLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = parts[2] || '';
  }
}

export class FlowStartScheduledRecordsLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = `${parts[2]} : ${parts[3]}`;
  }
}

export class FlowCreateInterviewErrorLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = `${parts[2]} : ${parts[3]} : ${parts[4]} : ${parts[5]}`;
  }
}

export class FlowElementBeginLine extends Method {
  declarative = true;

  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts, ['FLOW_ELEMENT_END'], 'Flow', 'custom');
    this.text = parts[3] + ' ' + parts[4];
  }
}

export class FlowElementDeferredLine extends LogEvent {
  declarative = true;

  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = parts[2] + ' ' + parts[3];
  }
}

export class FlowElementAssignmentLine extends LogEvent {
  declarative = true;
  acceptsText = true;

  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = parts[3] + ' ' + parts[4];
  }
}

export class FlowWaitEventResumingDetailLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = `${parts[2]} : ${parts[3]} : ${parts[4]} : ${parts[5]}`;
  }
}

export class FlowWaitEventWaitingDetailLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = `${parts[2]} : ${parts[3]} : ${parts[4]} : ${parts[5]} : ${parts[6]}`;
  }
}

export class FlowWaitResumingDetailLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = `${parts[2]} : ${parts[3]} : ${parts[4]}`;
  }
}

export class FlowWaitWaitingDetailLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = `${parts[2]} : ${parts[3]} : ${parts[4]} : ${parts[5]}`;
  }
}

export class FlowInterviewFinishedLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = parts[3] || '';
  }
}

export class FlowInterviewResumedLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = `${parts[2]} : ${parts[3]}`;
  }
}

export class FlowInterviewPausedLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = `${parts[2]} : ${parts[3]} : ${parts[4]}`;
  }
}

export class FlowElementErrorLine extends LogEvent {
  acceptsText = true;
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = parts[1] || '' + parts[2] + ' ' + parts[3] + ' ' + parts[4];
  }
}

export class FlowElementFaultLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = `${parts[2]} : ${parts[3]} : ${parts[4]}`;
  }
}

export class FlowElementLimitUsageLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = `${parts[2]}`;
  }
}

export class FlowInterviewFinishedLimitUsageLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = `${parts[2]}`;
  }
}

export class FlowSubflowDetailLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = `${parts[2]} : ${parts[3]} : ${parts[4]} : ${parts[5]}`;
  }
}

export class FlowActionCallDetailLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = parts[3] + ' : ' + parts[4] + ' : ' + parts[5] + ' : ' + parts[6];
  }
}

export class FlowAssignmentDetailLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = parts[3] + ' : ' + parts[4] + ' : ' + parts[5];
  }
}

export class FlowLoopDetailLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = parts[3] + ' : ' + parts[4];
  }
}

export class FlowRuleDetailLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = parts[3] + ' : ' + parts[4];
  }
}

export class FlowBulkElementBeginLine extends Method {
  declarative = true;

  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts, ['FLOW_BULK_ELEMENT_END'], 'Flow', 'custom');
    this.text = `${parts[2]} - ${parts[3]}`;
  }
}

export class FlowBulkElementDetailLine extends LogEvent {
  declarative = true;

  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = parts[2] + ' : ' + parts[3] + ' : ' + parts[4];
  }
}

export class FlowBulkElementNotSupportedLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = `${parts[2]} : ${parts[3]} : ${parts[4]}`;
  }
}

export class FlowBulkElementLimitUsageLine extends LogEvent {
  declarative = true;

  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = parts[2] || '';
  }
}

export class PNInvalidAppLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = `${parts[2]}.${parts[3]}`;
  }
}

export class PNInvalidCertificateLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = `${parts[2]}.${parts[3]}`;
  }
}
export class PNInvalidNotificationLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = `${parts[2]}.${parts[3]} : ${parts[4]} : ${parts[5]} : ${parts[6]} : ${parts[7]} : ${parts[8]}`;
  }
}
export class PNNoDevicesLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = `${parts[2]}.${parts[3]}`;
  }
}

export class PNSentLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = `${parts[2]}.${parts[3]} : ${parts[4]} : ${parts[5]} : ${parts[6]} : ${parts[7]}`;
  }
}

export class SLAEndLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = `${parts[2]} : ${parts[3]} : ${parts[4]} : ${parts[5]} : ${parts[6]}`;
  }
}

export class SLAEvalMilestoneLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = `${parts[2]}`;
  }
}

export class SLAProcessCaseLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = `${parts[2]}`;
  }
}

export class TestingLimitsLine extends LogEvent {
  acceptsText = true;

  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
  }
}

export class ValidationRuleLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = parts[3] || '';
  }
}

export class ValidationErrorLine extends LogEvent {
  acceptsText = true;
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = parts[2] || '';
  }
}

export class ValidationFormulaLine extends LogEvent {
  acceptsText = true;

  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    const extra = parts.length > 3 ? ' ' + parts[3] : '';

    this.text = parts[2] + extra;
  }
}

export class ValidationPassLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = parts[3] || '';
  }
}

export class WFFlowActionErrorLine extends LogEvent {
  acceptsText = true;
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = parts[1] + ' ' + parts[4];
  }
}

export class WFFlowActionErrorDetailLine extends LogEvent {
  acceptsText = true;
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = parts[1] + ' ' + parts[2];
  }
}

export class WFFieldUpdateLine extends Method {
  isExit = true;
  nextLineIsExit = true;
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts, ['WF_FIELD_UPDATE'], 'Workflow', 'custom');
    this.text = ' ' + parts[2] + ' ' + parts[3] + ' ' + parts[4] + ' ' + parts[5] + ' ' + parts[6];
  }
}

export class WFRuleEvalBeginLine extends Method {
  declarative = true;

  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts, ['WF_RULE_EVAL_END'], 'Workflow', 'custom');
    this.text = parts[2] || '';
  }
}

export class WFRuleEvalValueLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = parts[2] || '';
  }
}

export class WFRuleFilterLine extends LogEvent {
  acceptsText = true;

  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = parts[2] || '';
  }
}

export class WFCriteriaBeginLine extends Method {
  declarative = true;

  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts, ['WF_CRITERIA_END', 'WF_RULE_NOT_EVALUATED'], 'Workflow', 'custom');
    this.text = 'WF_CRITERIA : ' + parts[5] + ' : ' + parts[3];
  }
}

export class WFFormulaLine extends Method {
  acceptsText = true;
  isExit = true;
  nextLineIsExit = true;

  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts, ['WF_FORMULA'], 'Workflow', 'custom');
    this.text = parts[2] + ' : ' + parts[3];
  }
}

export class WFActionLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = parts[2] || '';
  }
}

export class WFActionsEndLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = parts[2] || '';
  }
}

export class WFActionTaskLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = `${parts[2]} : ${parts[3]} : ${parts[4]} : ${parts[5]} : ${parts[6]} : ${parts[7]}`;
  }
}

export class WFApprovalLine extends Method {
  isExit = true;
  nextLineIsExit = true;
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts, ['WF_APPROVAL'], 'Workflow', 'custom');
    this.text = `${parts[2]} : ${parts[3]} : ${parts[4]}`;
  }
}

export class WFApprovalRemoveLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = `${parts[2]}`;
  }
}

export class WFApprovalSubmitLine extends Method {
  isExit = true;
  nextLineIsExit = true;
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts, ['WF_APPROVAL_SUBMIT'], 'Workflow', 'custom');
    this.text = `${parts[2]}`;
  }
}

export class WFApprovalSubmitterLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = `${parts[2]} : ${parts[3]} : ${parts[4]}`;
  }
}

export class WFAssignLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = `${parts[2]} : ${parts[3]}`;
  }
}

export class WFEmailAlertLine extends Method {
  isExit = true;
  nextLineIsExit = true;
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts, ['WF_EMAIL_ALERT'], 'Workflow', 'custom');
    this.text = `${parts[2]} : ${parts[3]} : ${parts[4]}`;
  }
}

export class WFEmailSentLine extends Method {
  isExit = true;
  nextLineIsExit = true;
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts, ['WF_EMAIL_SENT'], 'Workflow', 'custom');
    this.text = `${parts[2]} : ${parts[3]} : ${parts[4]}`;
  }
}

export class WFEnqueueActionsLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = parts[2] || '';
  }
}

export class WFEscalationActionLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = `${parts[2]} : ${parts[3]}`;
  }
}

export class WFEvalEntryCriteriaLine extends Method {
  isExit = true;
  nextLineIsExit = true;
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts, ['WF_EVAL_ENTRY_CRITERIA'], 'Workflow', 'custom');
    this.text = `${parts[2]} : ${parts[3]} : ${parts[4]}`;
  }
}

export class WFFlowActionDetailLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    const optional = parts[4] ? ` : ${parts[4]} :${parts[5]}` : '';
    this.text = `${parts[2]} : ${parts[3]}` + optional;
  }
}

export class WFNextApproverLine extends Method {
  isExit = true;
  nextLineIsExit = true;
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts, ['WF_NEXT_APPROVER'], 'Workflow', 'custom');
    this.text = `${parts[2]} : ${parts[3]} : ${parts[4]}`;
  }
}

export class WFOutboundMsgLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = `${parts[2]} : ${parts[3]} : ${parts[4]} : ${parts[5]}`;
  }
}

export class WFProcessFoundLine extends Method {
  isExit = true;
  nextLineIsExit = true;
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts, ['WF_PROCESS_FOUND'], 'Workflow', 'custom');
    this.text = `${parts[2]} : ${parts[3]}`;
  }
}

export class WFProcessNode extends Method {
  isExit = true;
  nextLineIsExit = true;
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts, ['WF_PROCESS_NODE'], 'Workflow', 'custom');
    this.text = parts[2] || '';
  }
}

export class WFReassignRecordLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = `${parts[2]} : ${parts[3]}`;
  }
}

export class WFResponseNotifyLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = `${parts[2]} : ${parts[3]} : ${parts[4]} : ${parts[5]}`;
  }
}

export class WFRuleEntryOrderLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = parts[2] || '';
  }
}

export class WFRuleInvocationLine extends Method {
  isExit = true;
  nextLineIsExit = true;
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts, ['WF_RULE_INVOCATION'], 'Workflow', 'custom');
    this.text = parts[2] || '';
  }
}

export class WFSoftRejectLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = parts[2] || '';
  }
}

export class WFTimeTriggerLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = `${parts[2]} : ${parts[3]} : ${parts[4]} : ${parts[5]}`;
  }
}

export class WFSpoolActionBeginLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = parts[2] || '';
  }
}

export class ExceptionThrownLine extends LogEvent {
  discontinuity = true;
  acceptsText = true;
  totalThrownCount = 1;

  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.lineNumber = this.parseLineNumber(parts[2]);
    this.text = parts[3] || '';
  }

  onAfter(parser: ApexLogParser, _next?: LogEvent): void {
    if (this.text.indexOf('System.LimitException') >= 0) {
      const isMultiLine = this.text.indexOf('\n');
      const len = isMultiLine < 0 ? 99 : isMultiLine;
      const truncateText = this.text.length > len;
      const summary = this.text.slice(0, len + 1) + (truncateText ? '…' : '');
      const message = truncateText ? this.text : '';
      parser.addLogIssue(this.timestamp, summary, message, 'error');
    }
  }
}

export class FatalErrorLine extends LogEvent {
  acceptsText = true;
  hideable = false;
  discontinuity = true;

  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = parts[2] || '';
  }

  onAfter(parser: ApexLogParser, _next?: LogEvent): void {
    const newLineIndex = this.text.indexOf('\n');
    const summary = newLineIndex > -1 ? this.text.slice(0, newLineIndex + 1) : this.text;
    const detailText = summary.length !== this.text.length ? this.text : '';
    parser.addLogIssue(this.timestamp, 'FATAL ERROR! cause=' + summary, detailText, 'error');
  }
}

export class XDSDetailLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = parts[2] || '';
  }
}

export class XDSResponseLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = `${parts[2]} : ${parts[3]} : ${parts[4]} : ${parts[5]} : ${parts[6]}`;
  }
}
export class XDSResponseDetailLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = parts[2] || '';
  }
}

export class XDSResponseErrorLine extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = parts[2] || '';
  }
}

// e.g. "09:45:31.888 (38889007737)|DUPLICATE_DETECTION_BEGIN"
export class DuplicateDetectionBegin extends Method {
  declarative = true;

  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts, ['DUPLICATE_DETECTION_END'], 'Workflow', 'custom');
  }
}

// e.g. "09:45:31.888 (38889067408)|DUPLICATE_DETECTION_RULE_INVOCATION|DuplicateRuleId:0Bm20000000CaSP|DuplicateRuleName:Duplicate Account|DmlType:UPDATE"
export class DuplicateDetectionRule extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = `${parts[3]} - ${parts[4]}`;
  }
}

/**
 * NOTE: These can be found in the org on the create new debug level page but are not found in the docs here
 * https://help.salesforce.com/s/articleView?id=sf.code_setting_debug_log_levels.htm
 */
export class BulkDMLEntry extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = parts[2] || '';
  }
}

/**
 * DUPLICATE_DETECTION_MATCH_INVOCATION_DETAILS|EntityType:Account|ActionTaken:Allow_[Alert,Report]|DuplicateRecordIds:
 */
export class DuplicateDetectionDetails extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = parts.slice(2).join(' | ');
  }
}

/**
 * DUPLICATE_DETECTION_MATCH_INVOCATION_SUMMARY|EntityType:Account|NumRecordsToBeSaved:200|NumRecordsToBeSavedWithDuplicates:0|NumDuplicateRecordsFound:0
 */
export class DuplicateDetectionSummary extends LogEvent {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts);
    this.text = parts.slice(2).join(' | ');
  }
}

export class SessionCachePutBegin extends Method {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts, ['SESSION_CACHE_PUT_END'], 'Method', 'method');
  }
}
export class SessionCacheGetBegin extends Method {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts, ['SESSION_CACHE_GET_END'], 'Method', 'method');
  }
}

export class SessionCacheRemoveBegin extends Method {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts, ['SESSION_CACHE_REMOVE_END'], 'Method', 'method');
  }
}

export class OrgCachePutBegin extends Method {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts, ['ORG_CACHE_PUT_END'], 'Method', 'method');
  }
}

export class OrgCacheGetBegin extends Method {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts, ['ORG_CACHE_GET_END'], 'Method', 'method');
  }
}

export class OrgCacheRemoveBegin extends Method {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts, ['ORG_CACHE_REMOVE_END'], 'Method', 'method');
  }
}

export class VFSerializeContinuationStateBegin extends Method {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts, ['VF_SERIALIZE_CONTINUATION_STATE_END'], 'Method', 'method');
  }
}

export class VFDeserializeContinuationStateBegin extends Method {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts, ['VF_SERIALIZE_CONTINUATION_STATE_END'], 'Method', 'method');
  }
}

export class MatchEngineBegin extends Method {
  constructor(parser: ApexLogParser, parts: string[]) {
    super(parser, parts, ['MATCH_ENGINE_END'], 'Method', 'method');
  }
}
